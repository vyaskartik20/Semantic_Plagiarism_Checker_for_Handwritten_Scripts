DATABASE MANAGEMENT SYSTEMScanned with CamScanneruniquely identifies the types of the relation. This is calledthe primary key of the relation .In the given tables : SH, PH and (SH, PH) are primary keysof the tables supplier , parts and Sp srespectively .Advantages :1 ) User friendly representation .Given a query :. find st for suppliers who supply PtF = ' PI .... find pt for parts supplied by ' S+ = ' SI " .Both the queries incorporate similar Search types andare symmetouc . In the relational model, symmetsuc querysolving is symmetouc and poses no problem .ii ) Storage operations ( insertion , deletion, updation) aresimple to make .. Hierarchial Model:PantsPl Nut Red 12 KolkataP2 - - -P 3 .Supplier31 B. Raghuram Mumbai 30081 .....200SI . . . 400S2 D.K. Sharma Kolleata 200> aty incorporated forrelations hip maintenance .( we might have placed supplier at the root instead of "parts") Entities are grepresented as free structures . The structureimplies the relationship .: ) In this particular relation, "part " is superior to "supplier"For each part, there may be more than one supplier recordoccurrences. Each Supplies srecord also contains the shipmentScanned with CamScannerquantity . the association is represented by the parent - childrelationship , hence the name.iii ) In general, the roof may have any number of depend-ance . Each of these may again have any number of depend -ances and so on .IN > Asymmetric staucture - not convenient for userAdvantages and disadvantages:1 ) Symmetric query solving is not symmetric .1) the hierarchial model possesses certain undesirableproperties with respect to storage operations .Insert: to introduce a new supplier, dummy partsare to be introduced unless the supplier supplies some part .Delete: deleting a shipment information is to deletethe supplier record , implying that we may lose all informationabout the supplier, if it happens to be the only shipment forthe supplier .Update : problems due to gredundant occurrences. Any!Change , in say city of a supplier , siequires searching through"the entire database for all such supplier srecords ..1) the advantage is the naturalness, as natural processesare inherently hierarchial .. Network Model :An extension of the hierarchial model.SI B. Raghuram MumbaiSQ D.K. Sharma KolkataK3002001400300Pl ....P2 - --P3 ...Scanned with CamScannerRemark : Data is represented as records and links. Entity oct-urs as records and associations as links. More general thanhierarchial structure Connector chain represents shipmentquantities . No concepts of superiors and dependance . Eachconnector occurrence links only one supplies and only onepart .Advantages and disadvantages:1 ) Symmetoruc query solving is symmetsuc .11 ) Storage operations are simple .111 ) Disadvantage is the complexity of links.Relational database deign :Relational.. the output of a data -Real DesignHierarchialbase design is the uverwoldNetworkview .SIt is the responsibility of the DBA to design the database,S assigning the related data items of the database to columns3 of tables ( with respect to a relational model ) , in a mannerthat preserves deurable properties .The database designer has to consider many issues at thesame time. The final output of the logical database designprocess is the wer's schema, since the user's schema rep -regents the database designer's solution. The user's schemataare usually difficult to understand and change. The designeris constrauhed by the limited data- structure types supportedby the database system ( since the designer has to keep inemind the access paths. The search strategies are dependant onScanned with CamScannerthe conceptual schema . )The designer may have to consider the access paths ofthe record , i.e ., how to access a particular record type . Thedesigner may have to consider how to make the smetsieral andupdating more efficient.There are two common technologies Entity - Relationship appro-ach and Normalization approach towards database design.However , it turns out that the relational design boued on eitherapproach transform into relational form having nearly identi -cal sresults , and in fact , the two approaches reinforce eachother .E-R approach :The key idea to the E-R approach is to concentrate on the con-Ceptual schema . At this stage , the designer should view the datafrom the point of view of the whole enterprise . "This descriptionis called entepouse conceptual schema or enterprise sche-ma. This Should be a pure representation of the real world andindependent of storage and efficiency considerations . the de -Sign process can be viewed as a 2 - phase process -. Design enterprise schema ... Translate enterprise schema to user schema for the data -boue system ..Advantages of the 2-phase approach ,1 ) the database design process becomes simpler and betterorganized ." ) The enterprise schema is easier to design than the final schema ,Since, it neednot be srestoucted by the capabilities of the dataScanned with CamScannerbase system , and is independent of storage and efficientconsiderations .i) Enterprise schema is more stable than the user's schema.If one wants to change from one database system to another,one would probably have to change the wer's schema, but notthe enterprise schemain The enterpsuse schema represented by the E-R diagram ismore easily understood by non - EDP ( electronic data process -ing ) people .E -R concepts :The E-R approach defines a number of data classification ob-jects . Three fundamental data classification objects are :. entities. relationships.. attributesEntity : - An entity is a collection of distinguishable realworld objects , having common properties , and is of interestto the enterprise. Is represented as rectangular boxes in anS E-R diagram .EMPLOYEEPROJECTDEPARTMENTAn entity is usually mapped to an actual table, and each row ofthe table corresponds to one of the distinguishable objects thatmake up the entity , called an entity occurence / entity instance.Remark: There are many things in the real world , and onlyCsome of them are of interest to the enterprise . It s the resp-oncibility of the database designer to select the entities, whichare important.Scanned with CamScannerRemark: Choice of entities is a lkey step to database design.Relationship ! - Given an ordered set of entities 5 ,, E ...... Em.( may not be distinct ) a relationship R defines a smile of corres -pondence between the instances of these entities. Specifically,R orepresents a set of im tuples " (ene2 .... " em)lei e Ei, I siem ??which is basically a subset of the cartesian product of theentities : EIX E2x ... * Em ( rather the entity - instances ) . A parti -cular occurence of a srelationship , corresponding to a tuple ofentity instances ( elle2) .. " em), where eil Ei and Isism , iscalled a grelationship instance / srelationship occurrence. m isthe degree of the srelationship . Is srepresented as diamond -shaped bosces in an E-R diagram.EMPLOYEEWORKS -PROJECTSONBELONGS =Binary srelationship -ASSIGNEDTOTODEPARTMENTSTypes of relationships :a ) one- to- one: For each entity instance in either entity , there isatmost one associated member of the other enfity.E.g. HEAD- OF ( employee, depoortment )EFRminimum _ cardinality ( B, R ) = 0maximum- cardinality (E,R) = 1minimum-Cardinalily (F, R) = 0maximum-cardinality (FR)- 1Scanned with CamScannerb) many - to -one: A relationship is many- to - one, from entityE to entity F , if one entity instance in F is associated to 0 ormore entity instances in E, but each instance in E is associa-ted with atmost one entity instance in F.8.9: BELONGS- TO ( employee, department)ERminimum - cardinality ( E, R ) = 1maximum-cardinality (E, R) = 1minimum- cardinality (F, R) = 0mascimum- cardinality ( FR) =n .c) many - to - many : A relationship is many- to- many from entity Eto entity F , it one entity occurrence in F is associated with anynumber of entity occurrences of E, and each entity occurrence inE is associated with any number of entity occurrences of F.8.9: WORKS- ON ( employee, project )FRminimum - cardinality ( E, R) = 0maximum-cardinality (E, R) = nminimum- cardinality (FR ) = 0mascimeim - cardinality ( FR ) = n . 4.Remark: There may be many types of relationships betweenentities , and some of them may not be of interest to the enterp-suse . The database designer is responsible for the selectionof srelationships srelevant to the enterprise .Remarle: Choice of srelationships is a key step to databasedesign .Attributes : - An attribute is a data item that describes aScanned with CamScannerproperly of an entity or a srelationship. Je represented a.oval-shaped boxes in an FR diagsiam .elte_namedesig)PHP_nameP_ locWORKS-BalEMPLOYEEPROJECTSON( dur,addCh#BELONGSASSIGNEDTOTODEPARTMENTSd -name( A bare outline of the ER diagram of the database )Types of attributes :a ) Simple single - valued attoributes : simple single . valued att -gributes are called simple attributes &9: e-name , duration.b) Composite attributes: Composite attributes can be divided intosubpants, 8g: address : street+ state + pin code. Compositeattributes help us to group together related altoributes, makingthe modeling cleaner .C) Multivalued attributes: multivalued altoributes are thosethat can take on multiple values for a single entity instance.E .g: phone # , hobby .keysa ) Superkey : A superkey is a set of one or more attributes , that swhen taken collectively allows us to identify uniquely an entityinstance in an entity . Say if elt were absent in the above data - Abase, then ( e- name, address ) could be treated as a superkey .Scanned with CamScannerAgain ( e-name, designation, address ) is also a superkey . Thusclearly , there may exist many superkeys ; any superser of aSuperkey is also a superkey in an entity.b) minimal super-key or candidate key: A superkey forwhich no proper subset is a superkey is said to be a candidate key. It is possible that several distinct set of attributesCould serve as a candidate key. 89: Ot, ( e-name , add . )CompositeC) primary key: The polimary key is a candidate key that ischosen by the database designer as the poincipal means ofidentifying entity occurrences , within an entity . Usually , apsrimgay key is wed in references from other tables .Eq: et, pt, It in employee , project and departmentrespectively . ( Not considering phone+ as an attribute. )Transformation Rules:1) each entity in an E-R diagram is mapped to a single tablein a relational database . The table is named after the enfity .J Columns of the tables represent all the single-valued simple5 attoributes that are attached to the entity. A porimany key isselected for the entity. Enfily occurrences are mapped to therows of the table .11) Given an entity E, with porimary key attribute p ; a multi-valued attribute a attached to E in an E-R diagram , istable of its own .mapped to a table of its own. The table is named after theplural multivalued attoribute ( E.g. PHONES ). The columns ofthe new table are named after p ( et ) and a (phone #) ,and the rows of the table correspond to (p, a ) value pairs -representing all pairings of attribute values of a, associa -ted with entity occurrences quelative to p in E. the primaryScanned with CamScannerkey attribute for this table is the set of columns in pand a.iii, when two entities Eand F, take part in a many-to - one,binary srelation R, and the entity F represents the many side,of the bielationship, the relational table T, transformed fromentity Fshould include columns constituting the primary keysfrom the table transformed from E. This is known as a foreignKey in TRemark . This foreign key cannot take on null values .N ) When two entities E and F take part in a many-to - manybinary orelationship R, the relationship is mapped to a siep - snesentative table T, in the sielated orelational database de -sign. The table contains columns for all attributes in the pré-many keys of both tables transformed from entities E and F,and this set of columns forme the porimany key for T. It alsocontains columns for all attributes attached to the onelation --ship(Here, primary keys of either tables in the relationship arenot attached to the transformed tables of the opposite entite -es , at this leads to data redundancy .The phenomenon of treating a sielationship like an entity ,as described above , is termed aggregation .Refinement allows answering queries pertaining to crossentity references in a orelational database. Refinement bizingsforth the tome essence of sielationships in a snelational datas[base design . )Refined E-R diagram, as compared to the bone outlineof the E -R diagram :Scanned with CamScannerDatabase :A database is a collection of stored operational data usedby the application systems of some particular enterprise( R. CO. Engles )Database components: The components of a database are :database : A Large collection of data, stored in secondanJstorage .application programs: Run against this data, operating onin all usual ways .on- line wers: Interacting through terminals, performing alfunctions ( mainly retorieral )directapplication programswers( less interactive)( greaterinteraction ).database / data storage .(overlapped units : portions of databasevieeved by Single vers / groups - bouedon srequirement / access sights etc. ). Interaction with a database , primarily includes -retrieval, insertion, deletion, updation ( via direct usersapplication programs )The database is integrated, so that the database containsdata for many wers , and not just one. This implies :Scanned with CamScanner@#e-namedesighrs _workP#P-nameadd.Sal .P_ locEMPLOYEE KEWORKS -PROJECTSONphone #durPHBELONGS -ASSIGNED =TO( many - to( many - to .TOforeignmany )aggregationonekey( many - to .one )has a separateDEPARTMENTS Ktable mapped toit with albributesd# )d-nameelt and phone ##.Definitions:a ) weak entity : A weak entity is an entity whose occurrencesare dependant for their existence through a relationship R onthe occurrence of another entity called strong entity . There maybe occasional cases in which the entity occurrence of an entityare not distinguished by their attributes but srather by theirorelationships to entities of another type. These entities arecalled weak entities . whereas, the entities whose entityoccurrences can be distinguished by its keys are called strongentities. 8g:PERSONNEL(strong entity )ISA( weak entity )PILOTScanned with CamScanner1 ) Any one user will be concerned with just a small portion ofitii ) Different user's portion, will overlap in various ways, i.e .,individual pieces of data may be shared by differentvers .Online users :end-users : Most intero ctive.. casual users : users accessing the database withSome commercial query language.. naive users: users accessing the database throughmenues .application programmers : Write the menu applicationsused by naive users. The program must foresee the needs ofthe users , and be able to pose quesues during execution , toretrieve desired information from the database .database administrator (ABA) : The DBA is a team of com -puter professionals responsible for the design and maintenant !ce of the database .An enterprise is a reasonably large organization - a manu -facturing company , university , hospital , government organi -gation that maintain data that can form a database .Operational data: It does not include any purely transientdata ( Il0, work queue etc. ) . Transactions may cause a !!change to the operational data , but are not a part of thedatabase . ( Transactions in hotel management systems ,airline reservation systems etc. - may be required to be storedScanned with CamScanneras operational data , as customers may request a detailedtransaction listing . ) Associations or relationships betweendata , must also be stored as part of operational data . 8.9 :For a manufacturing company - details of projects handled,use of parts - supplied by suppliers - warehouse locations- employees : each being a distinguishable entity , hasrelationships / associations with one another.Centralized database :S1) centralized control of operational data.11 ) the ABA has the central responsibility of the operati -onal data ( taking care of critical section issues ).Tasks of a ABA :1 ) Deriding information content .11) Designing the database .- organize views , restrictions etc .iii ) Recovery mechanism ( frequency of backup issues ) andbackups .IN ) Authorization checks ..v ) Monitor and upgrade performance issues.Advantages / implications of a DBMS :1 ) the amount of redundancy in the stored data can be red .uced . Independent applications may have their own pouratefiles leading to redundancy and wastage of storage space .with centralized control, this sredundancy can be reduced.11) Inconsistency : the problem of inconsistency can also beScanned with CamScanneravoided to some extent . this property directly follows fromredundancy removal , implying, two enteries of the same infor-mation may lead to inconsistency ifone is updated .Remark: Sometimes, there are technical reasons for main-taining several distinct copies of the same data . Any such ready -?ndancy should be carefully controlled.111) Data shasting: Data can be shared, i.e ., not only the exis -ting applications can share the data in the database , but also ,new applications can be developed to operate against thesame shared data .v) Standards: Industry standards con be enforced andmaintained by the DBA. This simplifies problems of maintenan-ce and data interchange between installations .N > Security: Security siestoructions can be applied, the DBAcan ensure that the only means of access to the database isthrough proper channels and hence can define authosuzationchecks to be carried out , when access to sensitive data isattempted . this also implies pouracy across various user dep - "artments .vi) Integrity : Integrity can be maintained . The data valuesstored in the database , must satisfy certain types of conust -ency constraints . The problem of integrity is the problem ofensusring that the data in the database is accurate.vii) Ease of application development: Cost and time for developingnew applications are reduced . Studies show that , a programmercan develop an application 2-4 times faster. The reason beingthat the programmer is free from designing , building, and main- Ataining master filesScanned with CamScannerwill) Data independence: Separation of data from the apper -cation program environment Organization of data can changeand evolve , without any change in the application program ..9: field-size Change, file- organization change etc. It is amayon objective of database systems and may be defe -ned as the immunity of applications to change in the storagestructure and access strategy, i.e ., the applications conce-ned donot depend on any particular storage stouwcture oraccess strategy. May be viewed as a 2-stage independence. logical data independence: capacity to change theconceptual schema , without having to change externalschemas or application programs .. physical data independence : capacity to Change theinternal schema, without having to change the conceptualschema .Schema of a database , stands for the description of a data -base .Database architecture: 3 . schema conchitecture (ANSI/SPARC conchitecture ) :(externalExt. view ,Set. viewsget viewn level )external -conceptual mappingconceptual(an abstraction : pertains todata as viewed by the NBAschema/ levelconceptual - internaland not the actual storage )mapping : given byunderlined DBMSinternal( focuses on the actual storagestructure.Schema / levelof data, notviewed by the DBAData as in the secondary sto -rage )Scanned with CamScannerInternal level . This level has an internal schema, which definessthe physical storage structure of the DBMS , ie, how the data -base is actually stored ( depends on the data model of theDBMS). It desoubes the complete details of data storage andaccess paths for the database.Conceptual level: This level is defined by a conceptualschema through the Data Definition Language ( DAL ) of theDBMS package used. This is done by the DBA, Who decideswhat information is to be kept in the database . This is a repre- &sentation of the entire information content in the database, in aform that is somewhat abstract , in comparison to the way inwhich the data is actually ( physically ) stored .( Eg: physically a B-tree, but conceptually a table ) It maybe completely different from the way data is viewed by theuser . It describes what data are actually stored in the data -base , and the relationships that exist among the data .External level: This level is defined by a number of ext - oremal schemas or views. Most database users will not be con-cerned with the entire database, but need just a part of it.Thus , there are many external views of it, which basicallyconsists of definitions of various external record types in thatview .Remark : The conceptual schema is intended to include addisttional features like authosugation checks and validation pro-acedures.The DOMS is a software that :Scanned with CamScanneri) Allows the DBA to define the conceptual and externalmodel through the DAL. In most cases, the physical modeldefinition is part of the package.") Allows users to manipulate data through Data Manipula-tion Language (DML) commands and routines.in) Handles all accesses to the database, i.e ., controts theoverall operation of the database .Data Definition Language: A high-level non-procedural las-quage . It is a notation for describing the entities and rela -fronships among the data entities , in terms of a particulardata model . It is used to :1) Express the design of the database .11) Modify the design .hi ) Describe in abstract terms what the physical lay outof the database should be .Specify domain constraints , referential integrity , assertions , authorizationsData Manipulation Language: Used to manipulate data, i.eperform storage ( insert , deletion , retsuere etc. ) operations .Remark: The DDL and the DML depend on the DBMS packagewhich in turn depends on the data model .Data Models: In a centralized database, there are & typesof data models which form the heart of a database :1 ) Relational 11 ) Hierararchial 1Hi Network,. Relational Model :Scanned with CamScannerSupplier: ( entity : provides completeinformation)S#S_nameCitySIB. Raghuram Mumbai82A. K. Sharma Kolkata. table synonymouswith relationParts: ( entity ). record synony-P#p _ namecolourcwf . City .mous with instanceDNutRed12 Kolkataor tuple ...P 2Bott-Green17MumbaiPsScrewBlue17DelhiSp : ( A table that symbolizes a relationS#PHstymore than an entity )P.300SP 2200The statement : Supplier no. 81 of name!S.Pg400B . Raghuram stays in Mumbai : depictsS2P300a relationship which is best explainedin the SUPPLIER table.1) Entities and associatiations are viewed as tables Corre-lationships )11) Most convenient form for the users .1 N) For every tuple, a relation exists between every attoributeof the table , and the same relation holds for every tuplewithin a relation . And thus the name relational model .Within a given relation , there is one attribute ( may be aComposite attribute of 2 or more attoributes ) with values thatScanned with CamScanner In the example , a pilot is a specialization of personnel , or apersonnel is a generalization of pilot. The pilot entity may nothave a key, but can be identified by the personnel identifien.IS_ A is a weak relationshipb ) existance dependant entity : The existance of an entity occu -rence may sometimes depend on the escistance of another entityoccurrence in another entity .8.9 .EMPLOYEEPARENT -OFCHILDREN(existance dependant)In this poorticular case , the existance of children entity depends !on the existance of the associated employee . It an employeeleaves the company , the database shall not keep track of theChildren , Thus " CHILDREN" is an existance dependant entity .This is also a weak entity , though the weak entity childrenmay have a key attribute childrent . The sielationship PARENT_ OFis also a weak- srelationship ( many -to - many ) . It's possiblethat the existance dependant orelationship is a many-to - manymapping. 8. 9: If the father leaves the company , the childrenentity occurrence may still escist of their mother is an employee sof the company .C ) ID dependancy : If an entity cannot be uniquely identified ! !by its own attribute , and has to be identified by its svelati-Scanned with CamScanneronship with other entity (s), then we say that it has an ID dep-endancy on other entities.E. g. A street is unique only within a city, a city is uniqueonly withun a state and a state is unique only within a country.COUNTRYCONSISTSOFInorder to uniquely idenSTATEStify the address of a locali -IDon, we have to specify thenames of city , state andHAScountsry , in addition to thename of the street .Remark : An ID dependan -CITIESCy is automatically exist -IDance constrained , but anexistance constrained is notHASnecessary an ID dependaneysince , the existance dep -endent entity can still beuniquely identified by itsSTREETSkey .IDRemark: Choice of attributes is a key step to databasedesign .Scanned with CamScannerDependancies and normal,form :The goal in orelational design is to choose srelations that remainConsistant and have minimum inconsistency , auch sielations onesaid to be in the normal .form , In a normalized sielation, ofevery now and column position in the table , there exists preciselyone value , and never a set of values, i.e ., in a normalized neta -"tion , each of the underlined domains contain atomic valuesonly .Functional dependancy ( FR ) : Given a relation R , the attributesY of Ris functionally dependant on attribute x of R, iff each sX value in R has associated with it precisely one y value inR . Is usually represented as : X YNote : There may be same x values in different types of R.If Y is functionally dependant on x, then for the tuples havingsame x values , the y values must also be same .Considering a suelation :FIRST :S#S_statusS_city PHaty .As is evident from the1820LondonP1300table ,20P2200. s_status and s-city are20P3400functionally dependent onSI20P4200St .IS20P51 00. 3 _ status is functionallyIS20P6dependant on s-city .SQPoou'sP300. ( SH , PA ) form the keyS210400of the table .83PQ200S420LondonP22200S420P4200S420P5400Scanned with CamScannerFD diagram :SHS_statusstyPH3 - city|GEDifficulties in storage operations :. INSERTION - If we were to insert a record for .85 , who curren.fly supplies no part; the operation would not be possible asPH Cannot hold a null value .. DELETION - If we were to delete record 83 - 10 - Paris -....rather , if we were to delete the transhipment of 33; all recordscorresponding to 83 would be deleted .. UPDATION - If we were to update s-city of 81 from London toSan Francisco; we would have to search through all the recordsand update accordingly . A very tedious task , prone to inconsis-tencies .I Cause of the above problems : Absence of full-functional de -pendency ( FFD )Full functional dependancy ( FFD ) : Altribute Y is FFD on attori-bute x, it it is FD on X and not FD on any proper subset of theattoributes of x .In the above FD diagram , a partial dependancy is sievea-led .Resolution of the difficulties :Projection of FIRST as follows , creating two new sielations :SECOND: ( S# : key )SP : (( SH , PH ) : key )s#s_status s-cityS#PHsty3120Londoncrelationbetween supplie~ Supplier81300information52TOPooris1032PI800and poorts93...S 420LondonScanned with CamScannerCorresponding FD diagram .s_statusortyS#PH8-citySPSECOND.Now, the previously mentioned storage operations are tiendered easier .However , some other difficulties ore exposed :INSERTION: Rome : st . status = 50 cannot be inserted as a&# for the record would have null values.. DELETION : Say , there exists a record 85 - Rome - 50 , if itbe deleted , the record Rome - 50 stands deleted too .. UPDATION : Due to the siedeundancy In S-city , updation of -s.states is error - prone .The above difficulties aube due to the transitivity in thedependancies in SECOND, i.e ., the dependancy of supplierstatus on &# , though functional is transitive. this transitie-ty leads to difficulties over storage operations . Thus, wereplace SECOND by its projections as follows :sc ; ( Sc : key )CS : ( S_city : key )SI#s-cityS- city3. statusSILondonLondon2032Paris10Rome5034 LondonFD diagram: ( the FD-of SP stands unchanged andis to be included )- s_citys_city - s_ statusSCCSScanned with CamScanner ** Transitive dependancy, A functional dependancy X-Y in arelation R is a transitive dependancy if there is a set of attori-butes Z, that is neither a candidate key not a subset of anyKey of R, and both X - Z and Z-y hold.First Normal Form ( INF ) : A relation is In INF , iff all the underli-ned domains contain atomic values only . Eq: FirstSecond Normal Form (2NF): A relation is in QNK, if it is inINF, and every non - key attribute is FFD on the poimary key .8.9: FIRST is not in QNK, but SECOND and SP are in QNF.Third Normal Form (3NF); A relation is in 3NF , If it is in ONE andevery non - key attribute is non-transitively dependant on theprimary key. E.g. Sc, cs and SP are in 3 NFD .. Summary of normal forms, and the corresponding norma -lization technique :NORMAL FORMTESTNORMALIZATION VIELINFRelation should have Form new orelationsno nonatomic attribu - for each nonatomictes, or nested relati- altoibute orinestedone .relation.2NFFor relations , whereDecompose and setupthe porimany key con -a new sielation for ea -tains multiple attribu- ch partial key with itstes , no non- key attori - dependant attribute (s)bute should be ED on A relation must existpart of the porimarywith the osuginal poi -key .mary key and all its FDS3NFThere should be noDecompose and ser uptransitive dependancy a relation that includesof a non-key attribute the non-key attribute (s)on the porumary key, that FDetermine others ..Scanned with CamScannerDeterminant : Any attoribute ( s ) on which any one ore more attributesare FFD is ( are ) called a determinant , i .e. , if xey , x is termedas the determinant .In the relations covered , the determinants are as follows :.FIRSTSECONDSPScCSHS(S#, P#)S#8 -cityS_city .s_city.(SH, PH )Boyce- Coad Normal Form (BCNF) : A normalized srelation R, canbe said to be in BCNF if every determinant of R is a Candidatekey. It- Ris in BONF, it must be in 3NF, but the reverse s notalways tome . Here , Sp , sc and es are in BENF8.9 :Note : Any bincory sielation is in BCNF. Given a suelation: SUPP, with altsubutes : SH, 8_ name, S_sta-tus and s-city , where !.i) s_status and s-city are independent11) Both Sit and s_name come candidate keys.thus , the corresponding FA diagram is :SHS_statusIs_nameS-cityHere there exists no transitivity , and the determinants are :SH, s_name and ( SH, S_name ) and they are all candidateskeys . Thus , SUPP is in BCNF.Here, the determinants are disjoint .Given a relation : SSP, with attributes : SA, s_name, ph, city,Scanned with CamScannerand the candidate keys are : (3t, PH), ( PH, 3_name ).Now as is evident, the candidate keys are not dis joint, andthe determinants re : (st, pt), (suname, PH) , St, S-name.Here all the determinants are not candidate keys , andthus Ssp is not in BCNF .Moreover , 8 name is a sredundant attribute , and upda-tion of its values poses difficulties. Thus , oresolution of theproblem is through the perojections :SN ( SH or s_name : key)PS ( ( SH, PH ) : key )S#s_nameSH (Or sname ) PH OtyGruven a relation : SJF , with attoributes : student , subject ,teacher. the scules pertaining to the relation are as follows:1 ) For each subject , each student of that subject is tau-ght by only one teacher ." ) Each teacher teaches only one subject .Each subject is taught by several teachers . ...SJFStudentsubject teacherHere , ( student, subject ) isAnilmathsSena Candidate key . ( student ,physicsSahateacher ) forms an overlappingMadhu mathsSenCandidate too . Thus , an FDMadhuphysics " Duttadiagram would be !JAstudentteacherSubject KScanned with CamScannerHere , the determinants care : ( student , subject ) , ( student,teacher ), teacher ; but since teacher cannot be a candidatekey , the sielation is not in BCNF .Here, if the tuple canil - physics - sahay by deleted,then the srecord physics - Saha is sremoved . Thus , SIF issteplared by its projections: i ) ST ( student, teacher )11) TS ( teacher, subject ). Given a relation : EXAM, with attributes student, subject,position , and i) No two students obtain the same position inthe same subject .Thus , the candidate keys ore ( student , subject ) and ( subjectposition ). Here, the determinants are ( student, subject ) and( subject, position ) . Now, since all the determinants are candi-date keys,"the given suelation is in BCNF.Though the determinants and the candidate keys overlap,the absence of a subset of the candidate keys as a determi -nant sresults in none of the porevious difficulties wrising.. Guven a sielation :CTX 10Courseteacher textCourse teacher testAlKNDZugerNavatheAIWillsonNCKorthwinston.NavtheDBMSSCkorthHere, . every course has a givenNavathetext Set .SKSKorth. Several teachers can teachScanned with CamScannera course .. Assume that no matter who actually teaches a particularCourse, the same texts are used.Meaning of crx:OTX is an all- key relation . A tuple <citi x> appears in CTX.iff e can be taught by t who uses x as a reference . Note thatin the relation CTX . If the tuples << . ti , x , y and < C . , t2 ; 2)both appear , then tuples <e, ti, sn) and (C , t2 ; " > also !! !appear . Clearly , Crx contains a great deal of sredundancy .This leads to problems in upstate operations. 8.g. To add therecord that DBMS uses a new text Conoly , it is necessary toadd one tuple for each teachm of DAMS, as CTx is an all-keyrelation and is in BCNF.the lack of dependency of teacher on text is the source ofthe difficulties. .Improvement .Replacement of Crx by its all-key BONF projection? !CT ( Course, teacher ) ,ex ( Course , tesct )Extension of FDThe definition of FD may be extended by : the followingrepresentations :x › ›×a well- defined set -Shaving multiple valuesof y for avalue of x.In the second representation, the concept of multi-valued dep-endancy ( MVD ) is brought forth .Remark: Although a given course doesnot havebe a single cor -Scanned with CamScanner esponding teacher (teacher is not FA on course ), neverthe-less, each course has a well- defined set of correspondingteachers. this is called an MVD.there is an MVD of teacher on course and an MVD of texton course .Clearly , FD is a special case of MVD, and hence , MUD is ageneralization of FA, i.e, an FD is an MVD In which the setof dependant values, actually consists of a single value.[FD is a specialization of MVD ].Theorem :Lossless decomposition : A relation R with attributes ( A, B, C )Can be lossless decomposed into two projections: RI ( A, B) andR2 ( A, C ), iff, there is an MVD of B on A and an MVD of Con A inR .Fourth Normal Form ( 4NF ) : A normalized orelation R is said tobe in 4NF, whenever there exists an MVD in R, say of attubuteCTX is not in 4NF, but CT and CX are in UNF. LBon altubute A, thenall attributes of R are also FD on A]Relational model and query language :The srelational data model, represents the database as a collec-tion of tables, and there is a direct correspondence between theConcept of a table and the concept of a mathematical sielation . "Formal query language: A query language is a language thr-ough which a user srequests information from the database .These are typically high level languages compared to standa -red programing languages. Query languages ore classified asScanned with CamScannerfollows :Procedural : Specification of a sequence of operations .a.g: relational algebra.. Nonprocedural: the sequence of operations is not specifi-ed , but the information decired is ag: relational calculus .Relational Calculus is subdivided as follows !!. Tuple srelational calculus : A variable srepresentsa tuple of a scelation.. Domain srelational calculus: A variable srepresentsa data item or field or attribute ( simple single- valled )Commercial query language: Takes features of both proceduraland non- procedural query languages. Eg: 8buchered avery Lan -quage ( SQL )Relational Algebra !Relational algebra, essentially encompsuses .1 ) sfundamental operations - that allow construction of . "queries of our choice. The -fundamental operations are SELECT(J), PROJECT (IT), CARTESIAN PRODUCT ( X ), UNION (U ) andDIFFERENCE ( - )11 ) 4 additional operations - that are dependant on the fun -damental operations . The additional operations are: INTERSEC-TION ( 1 ), THETA- JOIN. ( M ), NATURAL JOIN ( X) and DIVISION( + )Use of any of the above operations on relations , yields a newOperation har 19 8Fundamental operations : a) han 19Scanned with CamScanner. SELECT : A unary operation (i.e ., it operates on a single relati-on ) sresulting in a hostigontal subset of that sielation .Syntax: 0 ( relation _ name )Predicateselect rows of relation-name, satisfying conditions inthe predicate . The predicate may compsrise of srelationaloperators ( =. ! != > < < < => > > >= ), logical operators / connectors( AND: A , OR: V, NOT : - ) or a combination of both .. PROJECT: A unary operation resulting in a vertical subset ofthe sielation under consideration .Syntax: TTattrib , altout ,, - altoutr( relation _ name )E Select columns , Corresponding to the attribute- listspecified , of srelation- name .. CARTESIAN PRODUCT : A binary operation lire, it operates on tworelations ) sresulting in the following :A. R = relationl X relation 2 where,if relation . I has mattributes and t, tuples and relation . 2 hasn attoributes and to tuples ,R has ( mtn ) attributes ( common attributes are srepeated ) and( tixt, ) tuples .. UNION : A binary operation with the following constraints :1) the two relations, RI and R2, under consideration must be "compatible, i.e. , should have the same number of attoributes .1 ) The ith attoubutes of RI and Rx, must be defined in the sameScanned with CamScannerdomain , I.e ., represent the same values , though they may be ide -ntefied by different attribute names .Syntax: RI U R2.Results in a sielation with tuples of RI and Re, no repeatctions .. DIFFERENCE : A binary sielation resulting in tuples of Rl thatcore not present in R2. Follows constraints of compatibility andSyntax : RI - R2. ( Set difference )Same domain values .The a fundamental operations / operators allow us to give acomplete definition of an expression in srelational algebra. KetE , and E2 be two srelational algebra esepressions . then , each of thefollowing are relational algebra expressions !. E, UE2 . E, - En. E , X E2( ... ( E ), where p=predicate on attribute ( s ) of E ... IT ( FI ) , where 3 = a list of some of the attributes of EL.Additional operations ...The five fundamental operations of relational algebra , J , IT, U, - , Xare sufficient to express any srelational algebra query . However,Some common queries are lengthy to express with just these &Operations . The four additional operations , each of which canbe expressed in terms of the five fundamental operations ,make the query length smaller in some cases ... INTERSECTION: Syntase: Rin R ., Sresults in a sielation withtuples common to both RI and R2.RIR 2RI n RQ = RI- ( RI -R2 )ARI-(RI -R2 )= RIn R2Scanned with CamScannerRemark : It is possible to write several equivalent sietationalalgebra expressions , that are quite different from one another .. THETA JOIN : A binary operation with syntax : RI XI Rz= [ ( RIX R2)NATURAL JOIN : A binary operation with syntax : RI Xt Rz( RIX R O ))RIURRRI . A , E RZ . A , A RI . A2 = R2 . A . A ... ARIA = RZ.A KWhere A ; ( i = 1 to k ) represents the common attubute set of therelations. the common attributes occur only once in the resul - atant sielation . ( RI ' , R2' >> attoubute sets of RI and R2 respectively )~. DIVISION: A binary operation with syntax: RI- RRE TT( RI ) - TT-( ( TTRI -RZRU po' ( RI ) X R 2 ) - R1 )RI - R2( RI" , RI' = attribute sets of RI and Re respectively ) . The cons -traints of the operation are ! If RI has ( mtn ) attributes andR2 has the lastn attributes, ie, the ( mtith attoubute of RIcoincides with the ith attribute of R2 , then the division opera -tion yields a relation ( R= R1 + R2 ) that has mattsubures .Usually Satisfies the "for - all" clause in a query.Proof of the equivalence :Clubbing / Concatenating together the im altsubutes to a singleattribute x and the nattributes to ' y for RI and RI, Let,RI :×RQ :and then RI + RRy ,y ,y2y 2(.: , is associated witheach value of 4 )LAtuple t is in ris iff: {r(R), s(s) are relations, SER; Tis is a relationa ) t is in TTR-s ( Y ) b ) For every tg in S, there is by inr ! b, [S] =t [s] , [, [R-97 . inon R-s ]Scanned with CamScanner Now , it TTRI ' - RZ', ( RI) by named A, i.e .,A = ITRI' - R2- es. ( RI) , then AX R2.=> ( AX Rp ) - R1XXYXY222 4 ,CCy2CCB = ITRI -RZ(( AX RP ) - R1). A - B === R1 + R2 .X2Relational algebra querues :Given a schema , " ABCEMP ( FNAME , MINIT , LNAME , SSN , BDATE , ADDR, SEX , SALARY,SUPERSSN , ANO )FOREIGN KEY .DEPT ( DNAME, DNUMBER, MGRSSN, MGRSTARTDATE )DEPT-LOC ( ANUMBER , DLOCATION )WORKS_ ON ( ESSN, PNO, HOURS )PROJECT ( PNAME , PNUMBER , PLOC , DNUM )DEPENDENT ( ESSN , ANAME, SEX , BDATE, RELATION ). Retowere the name and address of all employees who workin the "RESEARCH" department.RSCH_ DEPT( DEPT )ANAME = RESEARCH'Scanned with CamScannerRSCH_DEPT- EMP <- RSCH -DEPTEMPDNUMBER = DNORESULT <- TT( RSCH_DEPT_EMP )FNAME , LNAME , ADDRESS. For every project located in stafford , list the project number ,the controlling department number and the lastname, addressand birth date of the department manager.PJCT _ STAFFORD {J( PROJECT )PLOC = ' STAFFORDCNTRL - DEPTPJCr _ STAFFORD XDEPTDNUM = DNUMBERRESULT <- IT( CNTRL _ DEPT DAEMP )LNAME , ADDR , BDATEMGRSSN = SSN. Find the names of employees who work on all the projectscontrolled by department numbered 8.PTCTS ( PNO ) < TT(( PROJECT ) )PNUMBERDNUM = 5SSNS ( SSN, PNO ) <- TT( WORKS_ON )ESSN , PNOSSNS _ PJCTS< SSNS = PJCT5RESULT <- IT( SSNS - PJCTS Y EMP )FNAME , LNAMERetrieve the names of employees who have no dependantsSSN - DEPN - 75( DEPENDENT )( SSN)ESSNSSNS <- TT( EMP )SSNScanned with CamScannerSSN _ NDEPNSSNS - SSN_DEPNRESULT - TTFNAME , LNAME( SSN_NDEPN XI EMP )List the names of managers who have atleast one dependant.MANAGER ( SSN ) <- TTMGRSSN( DEPT )SSN_DEPN (SSN) <= ITESSN( DEPENDENT )MANAGER_ DEPN <- MANAGER 1 SSN -DEPNRESULT - TT( MANAGER _ DEPN DA EMP )FNAME , LNAME. Make a list of project numbers or projects that involve an em-ployee whose last name is ' SMITH ' - either as a worker or asa manager of the department that controls the project .SSN_ SMITH ( ESSN ) <- 71 1SSNINAME ='SRITH' ( EMP ) )SMITH_ WORKER - TTSSN _ SMITH A WORKS -ON )PNOMGR_ SMITH ( ANUM ) < ITSSN - SMITH DIDEPTDNUMBERMGRSSN= ESSNSMITH _ MANAGER ( PNO) < IT( MGR _ SMITH XI PROJECT )PNUMBERRESULT < SMITH _ WORKER U. SMITH - MANAGER.. Relational Calculus :6) doRelational algebra is a procedural language, since we write asrelational algebra expression , by providing a sequence of opera-tions that generates the answers to our query . In srelational cal-Culus we give a fosimal description of the information desired,without specifying how to obtain the information. Relational calculusScanned with CamScanneris non-procedural . The two fosims of srelational calculus ore :Tuple srelational calculus - A variable represents a tuple in asrelationDomain relational calculus - A variable represents a column/ Ffield in a srelation .Tuple Relational Calculus (TRC) :A general query of TRC is of the form St/p (t ) ?, i.e ., we wouldlike to obtain all tuples "t ", satisfying the predicate " P (t ) ".An attribute of a typical tuple t , is stated as t. A. " A " being anattribute in 't '.Foormal definition of TRC :A tuple variable is a free variable, unless quantified by ] ( there "exists ) or V ( forall ), else they are bound variables . Any numb -,er of tuple variables may appear in a formula. A TRE formula isbuilt up of atoms . An atom has the following fosims :-a) ser , where s is a tuple variable and r is a srelation( the use of the & operator is not permitted )b) S.x 1 u. y, where s and u are tuple variables, se is anattribute on which s is defined , y is an attribute on which u is adefined , and 0 is a comparison operator ( < . < == = ( ! = ) , > ,>> ) ; it is siequired that altributes x and y have domains cohosemembers can be compared by O.c) s. x Oc, where's is a tuple variable, in is an attribute onwhich s is defined, O is a comparison operator, and e is a cons-tant in the domain of attribute x .Formulae are built up of atoms , using the following tuiles : 1n14.a ) An atom is a formula .b ) If P. is a formula , then so one : -P, and ( p )c) If P, and Po are formulae, then so one: P. V Pp, Pin Pp.d) If P. (s) is a fosimula containing a free tuple variables, andris aScanned with CamScannerrelation, then Is Er (P. (S)), Vs er(P. (s) ) are also formulae .Safe TRC :A TRC expression may generate an infinite relation. e.g . Et / 7e(t);may not be a finiteset, and may contain values that do not belongto the database . Thus , such Tre expressions ore unsafe .To define a trestruction on the TRE expressions , we introduce theconcept of domain of a tuple srelational fosimula P." The domainof p [ dom ( p ) ] in the set of all values that appear explicitly in Por that appear in one or more srelations whose names appearin P . An expression 1 tl P ( t ) ? is safe , if all the following holds ! !a) All values that appear in tuples of the expressions , are val-ues from dom (P).6) For every expression like 7s (P. (s) ) in P, the subfosimulais true, iff there is a tuple. S, with values from dom (p. ), Suchthat P ( S ) is true .c) For every expression like vs (p. (s) ) in P, the subfosimulais toue, iff P, (s) is toque for every tuple s, with values fromdom ( p).Safe TRE expressions are equivalent to srelational algebsiaexpressions .QueriesUsing schema: "ABC". Retenieve the birthdate and address of employees named JOHNB SMITHt. BDATE, b. ADDRESS| EMP ( + ) AND t. FNAME = 'JOHN' ANDt. MINIT = 'B' AND t. LNAME : 'SMITH'S9. Retowere the name and address of all employees who work forthe RESEARCH department .Scanned with CamScanner St. FNAME, L. LNAME, t. ADDRESS EMP ( t ) AND ( 3d ) ( DEPT ( d ) ANDd. DNAME = RESEARCH' AND d. DNUMBER = t. DNO).. For every project located in Stafford, list the project number, theControlling department number and the depcortment manager'slast name, birthdate and address.P. PNUMBER, P. DNUM, t. LNAME, L. BDATE, t. ADDRESSPROJECT ( P) AND EMPLOYEE (t) AND P. PLOC = 'STAFFORD AND( ]d ) ( DEPT ( d ) AND d. DNUMBER = P. DNUM AND d. MGRSSN = t. SSN ) }Domain Relational Calculus (DRC):In this form , we use domain variables that take on values froman attribute domain , srather than values from an entire tuple . Anexpression in DRC 4 of the foom :> <zx ,, >> > > . . .. >< > > / P ( ac , , 2kg ) . .. . >< > > } , where x; ( Isign )represent domain variables and Psiepresents a formula com-"posed of atoms . An atom in DRC has one of the following forms :a ) <x, 26 .... Xn > Er, where ris a sielation on n attributesand x ; are domain variables or domain constants .5) 200 y, where x and y are domain variables, and I is aComparison operator , and the attoributes se and y have domainsthat can be compared by @c) 20 c, where x is a domain variable, 0 is a comparisonOperator and C is a constant in the domain of the attoribute forwhich x is a domain variable . .the DRC formulae are built up of atoms , using the followingsiles :a ) An atom is a formula .b ) If P , is a formula , then so come - P . , ( P. )c) If P, and Po are formulae, then so ore PIVie, PinP.Scanned with CamScanner1) It P. (se ) is a formula in x, where x is a free domain variable,then 3x ( P, (x) ) and vx ( P, (x) ) are also footmuune .Notational shorthand.Ja, b, c (p(a, b,c)) ~ 3a (ab(ac (P (a,b,c)))).Sale BRCDRC expressions like ( r xe. . "> - P (( .. .... ""n) } are untahe, as they allow values in the simsult that core not in the domainof the expression Thus , a DRe expression [ <x .. . . .. . " > / pfft xis safe , if all of the following holda) Al values that appear in tuples of the expression, come valu.es from dom (p)b) For every expression of the loom Jx (P. (x)), the subformulais toute iff, there is a value x in dom (P. ) auch that P. (x) ts torec) For every expression of the form Von (F (x )), the surfermala is truce iff, P. (n) in toure for all values of e from dom (F.)Queries .( using schema "ABe'). Cetsieve the birthdate and address of employees named' JOHNB SMITHSur | (aq) (ar) (93) (EMP (qrstuvwxyz) AND a JOHN' ANDTS B" AND S "SMITH ). Poterieve the name and address of all employees who wortefor the RESEARCH departmentSasv | (az) (31)(3m) (CMP (qrsturoxys) AND DEPT (Imme)AND LO RESEARCH AND MEE ){. For every project located in stafford, list the project number,the controlling department number and the department manager'slast name, bith date and addressScanned with CamScannerSiksuv/ (aj)(am) (an) (Et) ( PROJECT (hije) AND DEPT (Imno) ANDEMPLOYEE ( qrstuvwxyz ) AND j = "STAFFORD' AND K=M AND nat ) {. Structured Query Language (SOL):The general format of a data sretrieval 301 is :SELECT<aHoibule _ u'st >FROMconelation - listsWHERE< predicate >The output of the above is again a siedation having an attoributeList and corresponding values.Queries: ( using the schema ' ABC ' ). Retrieve the birthdate and address of the employee, whosename is ' JOHN B SMITH ' !SELECT BDATE , ADDRFROMEMPWHEREFNAME : ' JOHN' AND MINIT : 'B' AND LNAME = SMITH .Retrieve the name and address of all employees working inthe 'RESEARCH' department .SELECTFNAME , LNAME, ADDRFROMEMP, DEPTWHEREDNAME = 'RESEARCH' ANDANO = ANUMBER .For every project located in Stafford , list the project number,Controlling department number and the department manager'slast name, b_date and address.SELECT PNUMBER, DNUM, LNAME, BDATE, ADDR.FROM PROJECT, DEPT, EMPScanned with CamScannerWHERE PROJECT. PLOC : 'STAFFORD"ANDPROJECT. ANUM : DEPT. DNUMBER ANDDEPT. MGR. SIN ' EMP. SSN. Retrieve all employee SENSELECT SONFROM EMP. Retrieve all combinations of employee SUN and departmentname.SELECT SON. ANAMEFROMEMP, NEPT( Results received from cartesion product of EMP and LEFT ). Relieve whole records of employers working in department 5setter * all recordoFROMEMP.WHEREBANO A 'S'. Retrieve the salary of every employeeSELECT DISTINCT SALARYFROMEMP. For each employee, seloniere the FNAME, INAME and the samefor his / her supervisorSELECT C. FNAME, ELNAME, S. FNAME, 3. INAMEFROM EMP E, EMP S(=> ExS )WHERE 5.SON - E SUPERSSNScanned with CamScanner. Make a list of project numbers for projects that involve an emp-E.loyee whose LNAME= "SMITH, either as a worker or as a managerof the deprontment controlling the project .SELECT PNOFROM WORKS. ON , EMP , PROJECTWHERE ESSN = SSN AND PNUMBER = PNO ANDLNAME = 'SMITH' . )UNIONSELECT PNUMBERFROMPROJECT, EMP, DEPTWHEREANUM = DNUMBERANDMGR _ SSN = SSNANDLNAME = 'SMITH ' )OR,SELECT DISTINCT PNUMBERFROMPROJECTWHEREPNUMBER IN( SELECT PNOFROM WORKS_ON , PROJECT, EMPWHERE ESSN = SSNANDPNUMBER = PNO ANDLNAME = 'SMITH ' )OR ( SELECT PNUMBERFROM PROJECT, DEPT, EMPWHERE DNUM = DNUMBER ANDMGR. SSN = SSN AND/ LNAME = 'SMITH').(2X3 <)** the IN operator can also compone tuples of values in paran-Stheses .Scanned with CamScanner. Retorieve SSN of all employees who work the same ( hours , project )Combination , as some project employee with SSN : '128456789 .SELECT DISTINCT ESSNFROM WORKS . ONWHERE ( HOURS, PNO) IN ( SELECT HOURS, PNOFROMWORKS_ ONWHEREESSN = 123456789' ). Retouere the names of all employees whose salary is greaterthan the salary of all employees in department : '5'SELECT ENAME, LNAMEFROMEMPWHERESALARY>all( SELECT DISTINCT SALARYFROMEMPWHEREDNO = ' S ' ).** If X be a member of a set , while Y be a set, the expressionX > Y returns tome, if the value of x is greater than thatof all the members in Y .Retsieve the name of each employee , who has a dependant ofthe same name and same sex as the employee .SELECT ENAME, LNAMEFROMEMPWHERESSNINSELECT ESSNFROMDEPENDANT DWHERE D. ESSN = SSN ANDD. DNAME = FNAME ANDD. SEX = SEX )Scanned with CamScanner OR ,SELECT E. FNAME, E.LNAMEFROMEMP E , DEPENDANT DWHERED. ESSN : E-SSN ANDD. ANAME = E. FNAME AND.D. SEX = E -SEX .** In general, a query written in nested blocks and wing the =Or "IN" operator, can always be expressed as a single blockquery ..The constoucts with "IN", "Sony " , " Su ", allow us totest a single value against members of a set ( an entire set ) .SQL also allows<any< = any " , " > = any4 - any ,"! = any ", " ! = all "Since a SELECT generates a set of tuples , we may at timeswant to compone sets to determine if one set contains all themembers of some other set. such comparisons are made inSQL using CONTAINS and NOT CONTAINS.X CONTAINS Y> YS XX NOT CONTAINS Y => Y EX.Retrieve the names of all employees who work on all the proj -!!ects controlled by department "5","SELECT ENAME , LNAMEFROMEMPWHERE( ( SELECT PNOFROM WORKS.ONWHERE SSN = ESSN )CONTAINS( SELECT PNUMBERFROM PROJECTWHERE ANUM = '5' ) )Scanned with CamScanner** EXISTS ( CA ) siehorns tome, it atteast one theple exists in the resultof the tuple Q . Similarly , we have NOT EXISTS ( Q ) as opposed toExists ( a) , which suchains tore if a is empty .. An alternative approach to the query pertaining to the pretorievalof names of employees who have dependants of the same name andSex. Here, for each tuple of employee, the nested query thatpretoieves all dependant tuples with same SSN , name and sexas the employee tuple , is evaluated .SELECT FNAME , LNAMEFROMEMP EWHERE EXISTS( SELECT *FROM DEPENDANTWHERE E. SSN = ESSN ANDE. FNAME= NAME AND.E . SEX = SEX ) ."If atleast one tuple exists in the result of the nested query , thenI select that employee tuple for coutput.Retoueve the names of employees who have no dependants .SELECT ENAME , LNAMEFROMEMPWHERE NOT EXISTS( SELECT*FROM DEPENDANTWHERE ESSN = SSN )5. List the names of managers who have atleast one dependantSELECT FNAME, UNA MEFROMEMP EWHERE EXISTS( SELECT *Scanned with CamScannerFROM DEPENDANTWHERE ESSN = SSN )AND EXISTS( SELECT *FROM DEPTWHERE MGR _ SSN = SSN )** * CONTAINS YY CX=> YEXCEPT X = > 4 - x = @i.e ., Set X Contains set Y " is logically equivalent to "Y except( set difference ) X " is empty .. An alternative approach to the query pertaining to the retrier "al of the names of all employees working in all projects contro -led by department ' S ' .SELECT ENAME , LNAMEFROMEMPWHERE NOT EXISTS (( SELECT PNUMBERFROM PROJECTWHERE DNOM = ' 5' )EXCEPT( SELECT PNOFROMWORKS _ ONWHERESSN = ESSN )).. Retrieve the SSNs of all employees who work on project : 1 , 2or 2SELECT ESSNFROM WORKS ONWHERE PNO IN ( 1 , 2 , 3 )Scanned with CamScanner. Retorieve the names of all employees who donot have any supevisors.SELECT FNAME, LNAMEFROMEMPWHERESUPER-SSN IS NULLA missing / undefined / unapplicable.. Retrieve the last name of each employee and his / her super.visor, while ovenaming the attribute names as "EMP _NAMEand " SUPERVISOR _ NAME" srespectively.SELECT E.LNAME AS EMP_NAME ,S. LNAME AS SUPERVISOR _ NAMEFROMEMP ASE , EMP AS S .WHERE E. SUPERSSN = 8. SSN. Retrieve the name and address of each employee working inthe research department .SELECT FNAME , LNAME, ADDRno joinFROM ( EMP JOIN DEPT ON ANO = DNUMBER ) operation .WHERE DNAME : 'RESEARCH'** Aggregate functions and grouping : There are a number ofbuilt in aggregate functions like COUNT, SUM, MAX, MIN,AVG etc .. Find the sum of salaries of all employees, the maximumsalary, the minimum Salary and the average salary.SELECT SUM (SALARY), MAX ( SALARY ), MIN ( SALARY ) ,AVG ( SALARY )FROMEMP.Scanned with CamScannerFind the sum of the salaries of the employees in the sresear -Chdepartment, as well as the max, min and arg salary inthis department.SELECT SUM (SALARY), MAX (SALARY), MIN (SALARY ), AVG ( SALARYS )FROMEMP , DEPTWHEREDNO = DNUMBER ANDANAME : 'RESEARCH ' .Find the total number of employees in the company.SELECT COUNT ( * )FROMEMP .Find the number of employees in the sresearch department .SELECT COUNT ( * )FROMEMP, DEPT.WHEREDNO = DNUMBER ANDANAME = 'RESEARCH " .. Count the number of distinct salary values ...SELECTCOUNT ( DISTINCT SALARY )FROMEMP :. Retrieve the names of employees, who have 2 or more dep-endants .SELECT FNAME , LNAMEFROMEMPWHERE( SELECT , COUNT ( * )FROM DEPENDANTWHERE ESSN = SON ) > = 2 .Scanned with CamScanner. For each department sretrieve department number, numberof employees in that department and their average salary.SELECT ANO , COUNT ( X ), AVG ( SALARY )FROMEMPGROUP BY DNO .. For each project, sretrieve the project number, project nameand the number of employees working on the project .SELECT PNO, PNAME, COUNT ( * )FROMPROJECT , WORKS - ONWHERE PNO = PNUMBERGROUP BY PNO & HAD PNAME BEEN AKEY, GROUP BY PNAMEWOULD BE POSSIBLE .(OR GROUP BY ( PNO, PNAME ) ). For each project , on which more than 2 employees work ,retrieve the project number , project name and number ofemployees who work on the project .SELECT PNO, PNAME, COUNT (* )FROMPROJECT , WORKS . ONWHEREPNUMBER = PNOGROUP BY PNUMBER , PNAMEHAVING COUNT ( * ) >2 usually used where COUNT (x ) hasalready been computed .. For each project , sretrieve the project number, project nameand number of employees of department ' 5' who work on theproject .SELECT PNO , PNAME, COUNT ( * )FROM PROJECT, WORKS. ON , EMPWHERE PNUMBER = PNO ANDGROUP BY PNUMBER ,PNAME .ESSN = SSN AND ANO= '5'Scanned with CamScanner . For each department having more than 5 employees, sretrievethe department name , and the number of employees gettingmore than RS. 40. 000 .SELECT DNAME, COUNT (* )FROMDEPT, EMPWHERE DNUMBER = DNO ANDSALARY > 40000 ANDDNOIN( SELECT ANOFROMEMPGROUP BY UNOHAVING COUNT (*) > 5 ) .GROUP BY DNAME.. Reprieve a list of employees and the projects they are workingon, ordered by department , and within each departmentalphabetically by the lastname and the first name .SELECT DNAME , LNAME, FNAME, PNAMEFROMDEPT, WORKS . ON , PROJECT, EMP.WHEREPNUMBER = PNO ANDESSN = SSN ANDANO = ANUMBER .ORDER BY DNAME, LNAME ASC , ENAME.-ordered in the ascending order by default.DESC > descending orden .....Database Manipulation :Insert ; Delete ; Update .Scanned with CamScannerINSERT INTO EMPVALUES ('RICHARD'; ' K ', ' MARINI ' ... )INSERT INTO EMP ( FNAME , LNAME , SSN )other fields holdVALUES ('RICHARD', 'MARINI', '2358928516') default / full values .DELETE DEPENDANT the structure sremains , while all constituentdata are sremoved. Insertion hereafter into thetable is possible.. DELETE FROM EMPWHERELNAME = 'DEY'. DELETE FROM EMPWHEREANOIN( SELECT DNUMBERFROMSEPTWHERE DNAME =RESEARCH ' ! )Delete all employees whose salary is less than the averageSalary .DELETE FROM EMP" marks all records toWHERE SALARY < (SELECT AVG ( SALARY ) be deleted, during theFROM EMP )course of the executionof the query ; and the marked records the deleted physically at theend of the query execution. It may so seem that AVG ( SALARY ) isreevaluated after each srecord is marked , but practically the value7 is evaluated only once.An UPDATE clause is used to change the value of an attoribute in atuple . the WHERE Clause is used to select the tuple to be updated ( ifthis clause is not present => all tuples ), and a SET clause is used to no-Scanned with CamScannerminate the attribute whose value is to be changed and to specify the ahnew value .UPDATE PROJECTSET PLOCATION = 'MUMBAI', DNUM = 5WHERE PNUMBER = 10.. Increase the salary by 10% of all employees in the sresearch dep -cartment.UPDATE EMPSETSALARY = SALARY + ( 1. 1 * SALARY )WHERE ANO IN ( SELECT ANUMBERFROMDEPTWHERE DNAME = ' RESEARCH' )Views in SQL :A view is a single table that is deired from other tables. It does notnecessarily exist in its physical form . It is considered as a virtualtable, in contrast to the base tables, whose tuples are actually sto-sied in the database. We can think of a view as a way of specify -ing a table that we need to sreference frequently , even though itmay not exist physically.Eg, we may frequently use queries that sretrieve the employeename and the project names that the employee works on ; Sratherthan having to specify the join of 'EMP', 'WORKS -ON' and ' PROJECT'tables each time we issue the query, we can define a view that isa result of these joins . We can then issue queries on the view ,which are specified as "Single table grefsievals", srather than asgreteuerals involving 2 joins on three tables .A view is defined in SQL, using the CREATE VIEW Command!CREATE VIEW V AS <QUERYYScanned with CamScannerE.q: CREATE VIEW WORKS_ ONI ASSELECT FNAME, LNAME , PNAME , HOURSFROMEMP, WORKS_ON , PROJECT MANYWHERESSN = ESSN ANDsame altoribute names asthe tables are used in thePNO = PNUMBER .viewHere, we need not specify any new attribute names. It inheritsthe names of the vieco attributes from the defining base tables . EMP,WORKS _ ON , PROJECT .CREATE VIEW DEPT-INFO ( DEPT-NAME, NO_OF_EMP, TOT _SAL )AsSELECT ANAME, COUNT (*), SUM ( SALARY )FROMEMP , DEPTWHEREDNO = DNUMBERGROUP BY NAME.. Retrieve the first name and last name of employees who work onPNAME = 'PROJECT X' .SELECT FNAME , LNAME.1M3FROMWORKS- ONIWHEREPNAME = PROJECT X '!!!** A view is always uptodate , i.e. , 1 - we maily the tuples inthe base tables , on which the view is defined , the view autom-atically reflects these changes. This is done by the underlinedDBMS.If we donot need a view anymore , we can use the DROPVIEW Command to dispose it off. E.g. DROP VIEW SEPT-INFO.Scanned with CamScanner** Updating views :Considering the works. ONI viero, and suppose we issue the com-mand to update alloribulePNAME of JOHN SMITH from PROJECTXto PROJECTY.UPDATE WORKS. ONISETPNAME : PROJECT YWHEREFNAME = 'JOHN' ANDLNAME = 'SMITH' ANDPNAME : 'PROJECT X':. Possible reflections of change on base :This query can be mapped into several updates in the base 're --lations to give the desired update on the view .a )UPDATE WORKS _ ONSET PNO = ( SELECT PNUMBERFROM PROJECTWHERE PNAME = 'PROJECT Y ' )WHERE ESSN = (SELECT SONFROMEMPWHEREFNAME : 'JOHN' ANDLNAME : ' SMITH ' )ANDPNO = ( SELECT PNUMBERFROM PROJECTWHERE PNAME : 'PROJECT X ' )6)UPDATE PROJECTSETPNAME = PROJECTY '[In cases where instances per-WHERE PNAME : 'PROJECTX' taining to PROJECTy donot exists** Ingeneral, we cannot guarantee that any view can be updated ,,whenever, on update on the view can be mapped to more than one,update on the under lying base, we must have a certain procedureto choose the desired update . we can make the following obsea - sScanned with CamScannervations:a) A view with a single defining table is updateable , if the view attoributes contain the primary key , or some other candidate key of thebase sielation, as this maps each view tuple to a single base tuple.b ) Views defined on multiple tables using joins , are generally not up-dateable.c) Views defined using grouping and aggregate functions are notupdateable .As a result of these observations , most database systems impose thefollowing constraints :A modification is permitted through views, only if the view inquestion is defined on terms of one erelation of the actual relatio -nal database .Transaction Processing :We consider an interleared model of concurrent execution . The exe-cution of a program that accesses or changes the content of the data-base is calleda transaction . In our case , itsrefers to a program exe-Scutcon that updates the database unless we explicitly state otherwise .Basic database operations :READ ( 2x, X ) : x : program variableX: database item. : x< X.- READ ( X ) : XXX .WRITE ( X ) : X - Xprogram variabledatabase item .foumitive operations of READ (X ) : -Primitive operations of WRITE (*). locate data items in disk block .. locate data item in disk block.J. read block into main memory buffer ,. stead block into main memosyif not present already .buffer , if not present already .locate date item in buffer and. modify data items in buffer ( fromassign to program variables .program variables ) and write bufferScanned with CamScanner content into dick* The recovery manager is a subsystem of the NOMS pookage. It deci-des if the buffer Content is to be transferred to the dick immediatelycr later. (19:12 Mois. We have a variable ( 8 ) holding the number of bookings made onairline Ais while (4) halde the same for airline As, Transaction ( T. )is Concerned tod discarding n seats of A .. and booking those seats entoAs , while To is concerned with booking im seats of A.ToRCAN (x )READ (x)<- x -nxxx+m.Consistency check: x+9WRITE (x)WRITE (x)constantREAD (*). We are unaware of the or -der of transactions Consit -WRITE (Y)ening arbitrary.get , initial values be as follows: X 80 ; n . 5 ; m . 4A) T, and To serially executed => X 1 79B ) Considering a schedule ,SaREAD (X )X= 75X-x-nREAG ( X )x=x+max: 34X - 75WRITE (x )willenREAD (4)WRITE ( x)fisc- 24overouitien (ie, lastWRITE ( Y )update lost )LOST UPDATE PROBLEMThe lost update problem occurs when two transactions, that access theSame database items, have their operations Intexleaved in a way ,Scanned with CamScannerthat makes the value of some database item incorrect .c) Considering a schedule : $,READ ( X )value read is dertyX=X-nsince T' is not yet comp-X= 75WRITE (X )lete, - > Scope of changeREAD ( * )to X .X = x + mWRITE ( x ) 21 = 79.READ ( 4 )Y's value22 failure ( T1)oremains unchanged. T' not complete, might need to undo all operations.DIRTY READ PROBLEMThe disity stead problem occurs when one transaction updates adatabase item and the transaction fails for some reason in future.In between , the updated item is accessed by another transaction ,before it is changed to its osuginal / final value.d) Considering a schedule that psrimarily aims at summagugingJ the total transactions of the day :30Qum = 0READ (A)Sum+= AINCORRECT SUMMARYREAD ( B)PROBLEMSumtz BREAD (X )x = x -nWRITE (X )READ (X)sumt = xreads incorr-READ ( 4 )ect value ofy.Sum + = y-: Summary = ( actual - 2 )READ ( Y )Y = Ytn WRITE (G )Scanned with CamScannere ) UNREPEATABLE READ : This problem occurs when another transactionsmodifies a data item, read Continuously by another transaction - thusleading to stead two different values of the same data item, whena single value is expected .the five aforementioned problems depict the need of concurrencycontrol.Transaction Properties ( ACID properties ) :a ) Atomicity - A transaction is an atomic unit of processing , eitherperformed in entitity or not performed at all.b) Consistency - Transactions must take the database from one consis -tent state to another .c ) Isolation - A transaction should not make its updates visible toother transactions , until it is committed .1) Durability - Once a transaction changes the database, and thechanges are committed , these change's must never be lost becauseof Subsequent-failures . ( Both Ti and T, need to be aborted andthe transactions undone in 8% )Transaction OperationsTransaction States.Start . transactionActiveMarks the beginning of transaction execution . The transaction entersthe active state .read / woriteThese specify read / wsuite operations on the database items, that areexecuted as part of transactions .End. transactionPartially committedSpecifies read / wsite operations have ended , and marks the endlimit of transaction execution.At this point it is necessary to check whether the changes introduredScanned with CamScannerby the transaction can be permanently applied to the database ,or that the transaction has to be aborted if it has violated concur-reney checks or for any other reason .The concurrency control techniques require to ensure that thetransaction didnot interfere with other executing transactions .Also, some recovery protocol needs to ensure that a system failurewill not sresult in an inability to srecord the changes in atrans-action permanently .CommitCommittedThis signals successful end of the transaction , so that any changes executed by the transaction, can be safely committed to thedatabase .If all the concurrency checks ore successful , the transaction issaid to have reached its commitpoint and enters the committedstate .About / rollbackfailedThis signals that the transaction has ended unsuccessfully , sothat any changes / effects that the transaction may have appliedS to the database , must be undone . A transition can go to the failedstate , it one of the checks fails or if it is aborted during its ac-five state . The transaction may then have to be rolled back .terminated .This state corresponds to the transaction leaving the system .Transaction log :The recovery manager ( system ) maintains a log to keep track ofau transaction operations . It permits recovery from transactionfailures . The log is periodically backed up to archival storage ,to quand against disk / catastrophic failures.Typical log entries : ( Donot concern the operations ).[start , transaction T ] => T ( transaction identifier ) has started execu-Scanned with CamScannertion .[write. T , X, old-value, new-value ] sei database item , presen-ce of " old-value " in the log entary allows undo transaction operations ? .[ Read. T , x ] ( not a necessary log entary )[ commit T] => Thas successfully completed and afirms that itseffect can be committed to the database.[ Abort T ] => Thas been aborted.( sometimes, we might have to siedo - execution of the log - toacquire the present or latest database scenario - due to theOccurrences of failures / catastrophe . )** Some recovery mechanisms perform deferred updates whileothers perform immediate updates .Schedules : A schedule 8 of on transactions : Ti. .... Th, is an ord -esting of the operations of the transactions , so that for each trans -action To in 8, the operations of T, in 8, must appear in the sameorder in which they appear in Ij. However the operations fromother fransactions I can be interfeared with the operationsof Ti in 8 .[ sa , So , Sc ] ..SaSbri (sc ). >> read in Tire ( x )Conflicting1W, ( 22 )W. = > worite in T.w, ( se )Operationl .C ; = > Commit T.n ( 4 )W, ( x )Q = = > about Tiw , ( se )C2C2m (4 )W (4 )C,Scanned with CamScannerConflicting operationsTwo operations are said to conflict if :a) they access the same database item .6 ) must belong to different transactions.c) alleast one operation is a losute operation .Recoverable schedule.A schedule is said to be recoverable , if no transaction Tin S,Commits until all transactions T' , that have woutten an item ,that Treads , have committed .Following 86 , T'a T ., To Te ,we have the sequence , w, (Gr )To ( 2 )However , T'commits psuor to T' , and thus Sb is not recovera -ble [8a on the other hand is recoverable ] .Cascading rollback ;"w , ( x ) , w , ( x ), Y2 ( x ), n. ( 4 ) , Wa ( x ), w. ( Y ) ja,ja3L postponed to after commit ( 1 ) in cars ten .When an uncommitted transaction has to be rolled back , sinceIt read an item woutten by a transaction that failed , the phe -nomenon is termed cascading rollback .As in Sh , To is rolled back since T, has failed and needs to berolled back . ( the isolation property ceases to hold ).** A schedule is said to avoid cascading rollback, it- everytransaction in the schedule only ereads items that were work. cascadeless - transactionsthen by committed transactions .eschedue, read items only in com -mitted franeachone .x 2 9 ; W , ( x , 5 ) , W Q ( x , 8 ) , a ,strict schedule :- cascadelen butnot streetAnother restricted schedule called struct schedule, wheretransactions can neither stead or worite an item X, untill thelast transaction that werote X has committed / aborted .Al street are cascadeless, but not vice- versa.Scanned with CamScanner Serializability Theory :The database system must control concurrent execution of transactions ,to ensure that the database state remains consistent .All transactions cre mutually independent as we have assumed .Say, we have fransactions Ti, T2. ..... Th, then serially we can have n!serial schedules . As we have assumed that the transactions re mu -tually independent , then any schedule is a correct schedule. 80 ,Every serial schedule is correct.For schedule S6; which is a non-serial schedule, it is serializable asit is equivalent to a serial schedule .Definition : A schedule s of n transactions is serialigable if it is equi -valent to some serial schedule of the same n transactions .Clearly Schedule Sa is not serialigable, whereas Sp is serializable( provided all operations work ) .Equivalence of schedules :. Result equivalence: (as shown before )Consider a schedule S, and So with one transaction eachS92Say initially x= 100; thenREAD ( X )READ ( X )both the transactions / schedex= X+10;X=X* 11les produce 110 each. ButWRITE ( X )WRITE ( X )this doesnot state their equi -valence, 80 in this case we discard sresult equivalence.. Conflict equivalence!?Now, if we arewrite 80 as :Saday we have a serial schedule 8 :92 ( 22 )522 ( 72 )conflicting operali -92, ( y )102 (22 )onsScanned with CamScannerSeIf for 2 schedules ( with the same transac.221 ( x)372 ( x )1w, ( x )tions ) all the conflicting operations are insi ( y )wa(x)the same order , then it is termed conflicti -w, ( y )2 2ng equivalence .22, ( x )Now , if a non-serial schedule is conflict -22,2 ( x )co, ( x )W 2 (x )ti(s)ing equivalent to a serial schedule, thenw , (4 )this non-serial schedule is always correct ,C 2:as a serial schedule is always correct .Here , it is evident that Sa is neither conflict equivalent to Se nor to5 Sj , as the order of their conflicting operations are not same. So, it isnot serializable , hence not correct .Considering another schedule S.:SbSo27, (x )4 4 ( x )Here , we see that Sois conflictAw, (x ).w. (x )equivalent to the serialigedconjucting operations2 2 ( e )Ju ( y )schedule Se ; thus , SE is co -.w 2 ( x )w, ( 4 )vreet ..C2CISry ( 4 ). 372 ( x )w, ( y)* co 2 ( x ) vC2 .Definition :Two schedules are said to be conflict equivalent if the order of the con-flicking operations is the same in both schedules. ( any two conflicting op. ). A schedule S is conflict serializable if it is conflict equivalent to someSerial schedule s'. [ 8a is not conflict serializable to either of Sc orsc- Test of conflict serializability :Consider the following schedule with & transactions :Scanned with CamScannerT.Construct a precedence graph as follo.n (7 )-: smFor each transaction T; in schedule 9.Wcreate a node labeled T; in the preceed-n(y)ence graphT.rt(x)w (x)For each case in 3 .w(y). where I executes a read (x) afterw (2)a twsite (x) executed by T ,. Createn(x)an edge from T, to T in the preceedances72 (s )graphT.w (x )When Ti executes a write (x) after Ti executes a tead (x), Createan edge from I to Ti in the preceedance graph. When Ti executes a comite (x) after Ti executes a coute (x), createan edge from Ti to Ti in the preccedance graph. The schedule 3 u serialigable iff the precendance graph has no one-les.Numbering of the notes is clone no -followusScanned with CamScannerIt each step we find out the terminating node in the sremaining graph ,i.e ., the node whose row has all 0's ; and number / label that nodecouth the next highest number . we srepeat this tle all the nodesare successfully numbered .-3-4)O€3O-3O(b)-OOHere , affer this step we donot find any other terminating node inthe remaining graph ; none of the rows have all 0 entories . Thus , wecan conclude that the siemaining graph has a cycle .** Graph ( a ) has no cycles, so if it is a precedence graph of tran-sactions, we can say that it is serializable; and its serializableschedule is of the order Ji, Tg , T4 , To.whereas, graph ( b) has cycles , and if it is a schedule graph ,then it is not serializable .S- View resvalinability and view equivalence :Two schedules $, 9 are said to be view equivalent if the followingholda :1 ) the same set of transactions participate in S and S'2 ) for any operation r ; ( x ) of Ti in S , if the value of x, read bythe operation , has been written by cw; ( x ) of Cor if it is the osci-? ginal value of x, before the schedule started ), the same condi -tions must hold for the value of x nead by r, (x ) of T; ins !!3) if w (4) of T" is the last operation to cosite Y in 3, then g (4)of Te must also be the Last operation to wsrite Y ins '.The concept behind view equivalence is that, as long as each readScanned with CamScanneroperation of a transaction steads the sresult of the same losute op"eration in both schedules , the cwoute operations of each transaction.must produce the same resulta. The read operations are hencesaid to see the same new in both schedules . Condition 3 enirres -that the final walk operation on each edata item is the same inboth schedules, to the database state should be the same at theend of both schedules .A schedule 8 is said tobe view serializable, if it is view equiva-7lent to a serial schedule . ] [ r ( x ) , w . ( x ) , w . ( x ) , W 3 ( x ) , e, . Ca ( 3]blind wsil / 2 T, - To -Tg: view s. but not conflict sers** a) A serial schedule represents inefficient processing, sincethere is no interieaving of operations from different transactions . .5) A serializable schedule gives us the benefits of concurrentexecution , without giving up any correctness .c ) It is practically impossible to determine , how the operationsof a schedule will be interleaved beforehand ( since they aretypically determined by the Is schedulea ) .2 ) If transactions are executed at will , and then the result -and schedule is tested for serializability, we must cancel the effectss.of the schedules if it does not turn out to be Serialigable. I-clearly s/an impractical approach ] .e ) A more practical approach is to determine protocols or sets ofrules, that if followed by every individual transaction or it enfor -Ced by a ABMS Concurrency control Subsustem will eneure serializa -bility of all the schedules, in which the transactions participate.Protocols : ( Ensures the isolation property of concurrent execution ) S. Lock Based Protocols : -These protocols employee the technique of locking data items topreven multiple transactions from accessing the items concurrently ,A lock is a variable associated with a data item Lock ( X) that describesScanned with CamScannerthe status of the item with respect to possible operations that can beapplied to it. Generally, there is one look for each ciata item in the data-base . Locks one used as a means of synchroniging the access by concur-rent transactions to the database items.a ) Binary locking :A binary lock can have two states or values : locked ( 1) and un-locked ( 0) . A distinct lock is associated with each database itemX . If the value of the lock on X 21, X cannot be accessed by adatabase operation that requests the item ; If the value of theLock on X= 0, the item can be accessed when srequested. The arfollowing two atomic operations are wed with binary locking .LOCK - ITEM (X ) :L : IF (LOCK (X) == 0 )LOCK (X ) = 1 ;ELSE9WAIT UNTIL LOCK ( X) == O AND THE LOCK-MANAGER WAKESUP THE TRANSACTION ) ;GOTO L ;UNLOCK-ITEM (X):LOCK ( x ) = 0 ;IF THERE ARE ANY WAITING TRANSACTIONS ,WAKEUP ONE OF THEM ;The DBMS has a lock-manager subsystem to keep track of andcontrol access to locks.The binary locking scheme protocol :5 A transaction T --a) Must issue LOCK-ITEM (X ) before any read (X ) or cosLite (X )Operations are performed in T.b ) Must issue UNLOCK _ ITEM ( X ) after all read (X ) or worte ( x ) ope-Scanned with CamScanner mkiing are completed in T.will not issue LOCK-Item (X) if it already holds a lack an X.) will not issue UNLOCK- HEM (X) unless if already heids a lockan XThe binary looking scheme is greatbictive, Linge atmost one transac:-tien can held a look on a given item af an instant. It more than onetransaction tou'es to access X only for sleading, we should alloumthem to access X simultaneously .b ) Multiplemode looking :In this scheme , a lock associated with an item X has three states :read _ locked / shared - locked (1) , write. locked / exclusive- locked ( 2 )and unlocked (0) the following three atomic operations are wed inmultiplemode locking :READ_ LOCK (X):L : IF ( Lock (x) == 0)MLock ( x ) = 1 ;keep track of the number of tran -NO_ OF _ READS (X) = 1 ;Sactions holding a " Shared . lockon an item .ELSE IF ( LOCK (X) = 1 )NO _ OF _ READS ( X ) ++ ;ELSESWAIT( UNTIL LOCK ( X )SEO AND THE LOCK-MANAGER WAKESUP THE TRANSACTION ) ;GOTO L ;LNWRITE- LOCK (X):L: IF ( LOCK (X) = = 0 )WAIT ( UNTIL LOCK ( X ) == O AND THE LOCK -INLOCK ( x ) = 2 ;MANAGER WAKES OP THE TRANSAC -ELSETION ) ;Goto L ;3Scanned with CamScannerDALLE UP ONE OF THE (DATING, TRANSACTION?, IF ANY ,No_ of_ eenna ((x) -- ;IF (NO. OF- REAGE (x ) == 0)Lock ( x ) = 0;WAKEUP ONE OF THE WAITING, TRANSACTIONS ,IF ANY ;3The multimode locking scheme protocol :J A transaction T.a ) Must issue READ _ LOCK ( X ) or WRITE _ LOCK ( x ) before anyr ( x ) is performed in Tb ) Must issue WRITE - LOCK ( X ) before any w (A) is performed in T.c) Must issue UNLOCK ( X ) after all - ( x ) and w( x ) are completedin T .d ) will not issue "READ_LOCK ( X ) and / or LORITE - LOCK ( X ) in it alreadyholds a read / write lock on X . ( May be relaxed in certain cases ) .e ) Will not issue UNLOCK ( x ) unless it already holds a sread /cosrite lock on X .An example of transactions that maintain the aforementionedprotocol :Scanned with CamScannerTIToInitially : X = 20 ; y = 30 .rlock ( y )(4)TI=> X 250; 4=80unlock (4 )T2rlock ( x)serial* ( x )Schedulesunlock (x)S2colock ( 4 )T2X= 70 . 4 =50r (Y)TY=X+YW ( 4 )Now following the schedule shownunlock (4 )alongside: X= 50; 4:50.co.lock ( * )32 ( x )As is evident , the schedule along -side is not equivalent to any of thew (x )Serial schedules ; and is thus in -undock (* )correct .observations :a ) Using bindoy or multiple mode locking schemes donot guaranteeserializability of schedules .b) An additional protocol, concerning the positioning of the locking~and the unlocking operations , in every transaction must be followed .C) Two- phase Locking protocol ( 2PL ) ;( Basic ) A transaction is said to follow the 2 PL protocol it all lockingOperations preceed the first unlock operation in the transaction.There are two phases in a transaction :a ) An expanding / growing phase , during which new locks onitems can be acquired , but none can be released .b) A shrinking phase, during which existing locks can be releasedbut no new locks can be acquired .Scanned with CamScannerNeither T , nor To follow the 2 PL. the QPL equivalent stands a :T , "To '* It can be proved that, if everyrlock (4)Ylock ( x )transaction in a schedule follows ther ( Y )r (*)2PL protocol, the schedule is quaranteedwlock (x )wlock (Y)unlock (4)to be sestualizable .unlock (x )Two- Phase locking may limit ther (x )r (Y)amount of concurrency that can occurXI= x + YY= Y + X .in a schedule . This is because , a " tW (X )w (4)transaction I may not be able tore -unlock (x)unlock ( 1 4 )lease an item x affer it is throughusing it , if T must lock an additional item Y later on ; or conversely ,T must lock the additional item Y before it needs it so that it canrelease x. Hence X mustoremain locked by T until all items that thetransaction needs to sread or wwrite have been locked; only can thenX be sieleased by T. Meanwhile , another transaction seeking to accessx may be forced to wait , even though T is done with X ; conversely, itIt is locked earlier , than it is needed , another transaction seekingto access Y is forced to wait even though T is not using Y yet . ( Dead -lock rand steovation )( conservative / Static ) : This scheme requires a transaction to lockall the items it accesses , before the transaction begins to execute,by predeclaring its readset and writeset . The readset of a tran-saction is the set of all items that the transaction reads, and thewouteset is the set of all items that it cosrites. If anyone of thepredeclared items needed cannot be locked , the transaction doesnot lock any item ; instead , it waits until all the items are availa-ble for locking . Is a deadlock - free protocol ; difficult to use inpractise because of the need to predeclare the readset and the losuite-set.( strict ) The most popular 2 PL scheme . It guarantees struct schedulesHere , a transaction IT does not release any of its exclusive (cosuite )Scanned with CamScannerlooks until after it commits or aborts. Hence, no other transaction conread or comite an item that is written by T unless T has committed ,leading to a struct schedule for Siecoverability. Is not deadlock- free,(Rigorous ) A more srestouctive vacuation of strict OPL, which also qua-sanlees about schedules. Here, a transaction. T does not release -any of its locks until after it commits or aborts , and so is easier toimplement than strict OPL .* The conservative 2 PL must lock all its items before it starts, 30once the transaction starts it is in its shorinking phase, whereos su-gorous QPL does not unlock any of its items until after it terminates( by committing ar aborting), so the transaction is in its expanding ph-ase until it ends.2PL - balie; comerrative, strict, sugorous.( dead )(x)(Recevtheo deadlesisbut lead )** A deadlock situation:TiT2Deadlock handling mechanisms !wlock (+ )a ) Deadlock prevention - Not allo-r (4)wing deadlocks to occur at all. Res -wlook ( x )tsuclive => less throughput .r (x)b) Deadlock detection - Allow de-wlock ( x )adlocks - identify reason - about. ~wlock (4)TIT 2stock (y )wait states .read ( 4) lock (x )read ( x ). Deadlock prevention protocols : -wlock ( 4 )Is used in situations concerning heavy transaction load . The variousdeadlock prevention schemes are :a ) Conservative Q PL .b) Assignment of an arbitrary linear ordering to each data item, andask the transaction authors to lock items only in that order ( not apractical assumption - as the programmer or the system requires to beaware of the chosen order of the items .Scanned with CamScannerc ) use of transaction timestamps. ( Might be implemented by counters-limited by permissible mascomum value. ) Here, it TS ( T) indicates thetimestamp of the transaction T , then TS ( T ) < TS ( T. ) if T is an oldertransaction. the various schemes under this methodology core asfollows : -i) wait-die scheme : If T; tories to lock X but is not able sinceX is locked by Ti; Here,( waiting for younger )IF TS ( T ; ) < TS ( T )THEN T; IS ALLOWED TO WAITELSEABORT T. (T; dies) AND RESTART IT LATER WITH THE SAMETIMESTAMP .ii ) Wound - wait scheme: If I tories to lock X but is not ablesince X is locked by T; Here ,( waiting for older )IF TS ( T; ) < T.S ( T; )THEN ABORT To ( T, wounds Ti) AND RESTART ITLATER WITH THESAME TIMESTAMP .ELSET, IS ALLOWED TO WAIT .* a ) It can be shown that both schemes are deadlock free .b ) Both schemes end up aborting the younger of the two transactions,that may be involved in a deadlock .C) Both techniques Cause Some transactions to be aborted and re -Started , even though those transactions may never actually causea deadlock .d ) Both schemes avoid starvation, i.e. , no transaction gets abortedrepeatitively , since timestamps always increase and transactionsare not alloted new timestamps when aborted. A transaction that isaborted , will eventually have the smallest time stamp .d ) No-waiting algorithm - In this algorithm, if a transaction is unable toobtaina lock , it is immediately rolled back and restanted affer a certainScanned with CamScanner time delay , without checking whether a deadlock will actually occur ornot .** Transaction rollback and srestart occurs unnecessarily.e) Cautious waiting approach - If T; tories to lock X but is unable asX is locked by Ti.IFT, IS BLOCKED ( waiting for some locked item )THEN ABORT TO AND RESTART IT LATER.ELSE~nSET STATUS OF T; AS BLOCKED AND ALLOW IT TO WAITLv* It can be shown that this scheme is deadlock free , by consideringthe time b ( T ) at which each blocked transaction T was blocked . Ifthe two transactions T ; and T. both become blocked , and T iswaiting on Ti, then b (T,) < b(TI), since Ti can only wait at a timeohen Ti is not blocked . Hence, the blocking times form a total orden-ing on all blocked transactions, so no cycle that causes a dead -lock can occur.f ) Lock time out - If a transaction waits longer than a system de -fined timeout, the system assumes that the transaction is dead-locked and aborts it , sregardless of whether a deadlock situationactually exists .** In wait-die , an older transaction is allowed to wait on a youngertransaction, whereas, a younger transaction requesting an item heldby an older transaction is aborted and restarted. Whereas, In thewound - wait scheme , a younger transaction is allowed to wait onan older one , and an older transaction srequesting anitem heldby a younger transaction preempts the younger transaction by aborting it ..Both Schemes aresult in aborting the younger of the two transactions ,Scanned with CamScannerthat may be involved in a deadlock . These two techniques ame de-adlock- free , since in wait-die transactions, transactions only waiton younger transactions so no cycle is created . Similarly , In wound.wait, transactions only wait on older transactions sonocycle iscreated .. Deadlock detection protocols :Is used In situations concerning low transaction load .Deadlocks can be described precisely in terms of a directed graph,called a wait-fer quapi. A node is created in the cwait for graph farea -ich transaction that is currently executing in the schedule. Whenevera transaction T ; is waiting to lock an item & that is currently lock-ed by a transaction Ti, create an edge Ti - Ti. When Ti releaseslocks on the items that Ti was waiting for, the directed edge is dro-pped from the wait for graph . We have a state of deadlock iff thewait for graph has a cycle . Ench transaction involved in the cycle 'ssaid to be deadlocked . To detect deadlocks , the system needs tomaintain the wait-for graph and pesuodically to involce an algorithmthat searches for a cycle in the graph .Following the deadlock situation : - ( as per the transaction statedbefore )TIT2(An edge is drawn for each depend -ancy . The graph is updated siegl -laily ) .. Recovery from deadlock :a ) Victim selection: Given a set of deadlock transactions, the victimSelection algorithm determines which transactions to srollback tobreak the deadlock . It should rollback those transactions that willincur minimum cost, which depends on factors like : -. How long the transaction has computed , and how much longer itScanned with CamScannerwill compute to complete its designated task.. How many data items the transaction has used, and how many morethe transaction needs for it to complete .. How many transactions will be involved in the sroll back.*. How many times a single transaction has been scaled back,( steuvation prevention ) .b) Rollback: Once the victim selection is over, it must be determinedOp to how far this transaction should be srolled back , The simplest so -lution is total scollback ( abort ) and srestent.However , it is more effective to scoll back the transaction only asfar as necessary to break the deadlock , But, this method requires theSystem to maintain additional information about the state of all thesunning transactions .C ) starvation: In a system where the victim selection is based oncost factors, it may happen that the same transaction is always pickedas a victim . As a result , this transaction never completes its designa -ted task. this situation is called strawation.One solution to avoid starvation is to include the number of roll -backs in the cast factor .1 ) Livelock: Another problem that may occur when it uses lockingis "velock. A transaction is in a state of uvelock, if it cannot proceedfor an indefinite period of time , while other transactions in the sys -tem continue normally. This may accen if the waiting scheme for lock -ed items is unfair , giving poriosity to some transactions over others.The standard solution to livelock , is to follow a scheme that usesa FIFO queue , where transactions are enabled to lock an item in theorder in which they originally srequested to lock the item.Basic Timestamp Ordering ( To ) protocol : Another approach that quar -antees serializability, involves using transaction timestamps to ordeltransaction executions for an equivalent serial schedule .Scanned with CamScannerThe basic To protocol, associates with each database item x, two time-stamp values :READ _ TS ( * ) - The aread timestamp of X. This is the largest time-stamp , amongst all transactions that have successfully sread item ( x ).WRITE _ TS ( X ) - The worite timestamp of x. This is the largest timestamp, amongst all transactions that have successfully wittem item (x).The TO protocel is as follocus :We have transactions Ti , Ta. T3 , Ta . Ts where TS ( L . )< TS ( GR ) < .... < TS ( TS ).If there be a schedule : T2, Ti, Ts , Tu , To where :read / Woute - Ts ( x )IIN Scenario 1 :T requests a WRITE ( X ). If (read-TS(X ) > TS ( T ) )=> the value of X that T was producing , was needed porcciously , and thesystem assumed that , that value would never be produced. Hence,the WRITE ( X ) Operation is rejected and T is aborted .. If ( wouters ( x ) > TS (T))J-> that T is attempting to losrite an obsolete value of X. Hence, thisWRITE ( * ) operation is rejected and Tis rolled back .Otherwisethe WRITE ( * ) operation is executed and WRITE _ TS ( X ) A set to TS (T )Scenario 2 :Torequests a READ ( X ). If ( woute-TS (x) > TS (T ))=> Tneeds to read a value of X , that was already overwsulten . HenceREAD ( x ) is rejected and Tis rolled back .. If (warite-TS(x) < TS ( G) )> the READ ( x ) operation is executed and Reach - TS ( x) = max Read- TS (x),TS ( T ) 2 .Transaction T that is rolled back by the concurrency control scheme, as are-Sult of either a sread / write operation being issued is assigned a nein timestampScanned with CamScannerand is orestarted .A locking timestamp : pessimistic " fone wait / rollback.8 validation protocol ( louerpage )** This protocol quarantees conflict semializability since it ensures that,any conflicting sread and write operations are executed in timestamporder .** One of the problems associated with this protocol is that, it doesnot avoid cascading srollback .. A modification of the basic To protocol - known as Thomas' LosciteRule - does not enforce conflict serializability, but it rejects fewer "cwsuite operations by modifying the checks for WRITE ( X ) operationsas follows. If ( WRITE- TS (X) > TS(T ) ) then T is attempting to wsute !an obsolete value of X . Therefore this warite operation is ignored ,and processing is continued without aborting T. The other twoChecks, al in the basic To protocol, siemain identical in this casetoo. ] write- item(x ) issued .Itread _ Ko (x ) , 78 ( ? ) then about, rolllacht, reject operation :, If aContinue processing " witte. item (x ) already outdated . Any conducts resolved I write TS ( x ) > TS (T)** Thomas write Rule makes use of view serializability by deletingobsolete vorite operations by transactions that issue them.* strict to: If read. (X) Write. ( X ) Ussued, such that TS ( T ) >write _ TS ( x ) ;then m/w delayed untill 'T' ( that wrote X) has committed ( i.e ., WRITE -TS (X) = TS ( TI) )**these protocols ensure deadlock avoidance, as no locks areissued .W. ( A ) , W, (B ) W2 ( A )12 ( 3 ) C , C2 recoverable , seualizable .Wa ( A ) w ( B )W . ( A )( B ) C . C2 -recov , nonserializable ( inconstaren )W , (A) W , ( B )w 2 ( A )N 2 ( B ) (2 -el- non recor , sembally > If nofeatures theew. ( s ) y ( 2 )wa( A ) r ( B ) C2a > normecow , hon serialicomptent else inconRecovery techniques :If a transaction fails after executing some of its operations, but beforeexecuting all of them , the database system must have a recoveryscheme for restoration of the database to a consistent state that ex-isted poion to the occurence of the failure. . "To make a successful recovery from transaction failures, the sys -tem log keeps the Information about the changes to data items during osytransaction execution ' , outside the database .af Database backup and recovery from catastrophic failures : the mainScanned with CamScannerTechnique used to handle cateratrophie failures is that of dance.booteup, The tohole database and the log core periodically copied ona stable alorage media. In case of catastrophic failures, the latestbackup copy can be selonded to disk, and the system can be re-striled , The system log is usually substantially smaller than thedaterbase itself , and hence can be backed up more frequently . A newsystem log it stabiled after cath backup operection . Hence , to stecoverfrom click failures:at the database is first siecreated on dick from its latest back-up copy :by then the effects of all the committed transactions cohose ope -ventions have been entered in the backup copy of the system log, rethen areconstoucted .6 ) Other techniques : -. Referred Update ( NO _ UNDO / RENO algosuitfim ). Tumediate Update ( UNDO / REDO algorithm )[checkpoint entories in a system log- Checkpoints are another entrytype in a system Jog . The srecovery manager decides at what intervalsto take a checkpoint, Taking checkpoints consists of the following ac -tions : 1) Suspend execution of transaction temporarily.11) Force cwsuite all update operations of committed transactions from main memosly buffer to disk .N ) Losute a checkpoint srecord in the log and force write theJog to disk . Llog checkpoint enloy : CHECKPOINT. ]ivy Resume transaction execution .Recovery based on deferred update : The idea behind deferred und -ate technique is to defer / postpone any updates to the database itseyuntil the transaction completes its execution successfully and sreachesits commit point the typical deferred update protocol is as follows : -Scanned with CamScanner I. A transaction Cannot change a database until it teaches ita comuni),point .2. A transaction does not sieach its commet paint und all is. ufrdateoperations are arecorded in the dog and the leg is facce written to dick,If a transaction fails before sreaching it's commit print, it wills not haveechanged the database in any way. Thus UNDO is not needed . it maybe necessary to RENO the effect of the operations of a commiliedhansaction from the log, since their effect may not have been verordedin the database Li.e ., changes sreflected in the carhe but not in thedatabase - checkpoint not taken ] . Thus , such an algosuthm is nameda NO-UNDO / REDO algorithm .We consider a system in which concumency control w.es thetwo-phase locking protocol. To combine deferred update with this proto-Col, we keep all the locks on items in effect until the transaction re -caches its commit point, after which all the locks are sreleased. Thisensures a strict and serializable schedule. Assume that checkpointentries care included in the log.Recovery ming deferred update in the multiuser environment :PROCEDURERDU-Mlise two lists of transactions by the system- Committed transactions list ( T ) since last checkpoint.- Active transactions lust ( T' )RENO all the cuscite operations of the committed transactions fromthe log , in the order in which they were written into the log .The transactions that are active and didnot commit, are effect "ely cancelled and must be resubmitted.REDO ( worite - op )Redoing a write operation conlists of examining its log entory[WRITE T, x, new _val ] and setting the value of item (X ) in the sdatabase to the new-val.(NO_UNAO, Since old-val is not stored ) .Scanned with CamScannerif the REDO operation needs to be idempotent. In fact, the whole reco-very process should be idempotent -, Clearly , if the system teils duringthe recovery process the next recovery might siedo certain omiteoperations that had already been siedone . The sresult of recoveryfrom a crash during srecovery should be the same as the result ofrecovery when there is no crash during srecovery .T.T3T4TSTimeto( checkpoint )( crash )a ) Ti has committed before checkpoint was taken at time t ,, but Ts andTH have not committed yet.b ) Before the system crash , at time to, Ts and To have committedbut Ty and Ts have not .C ) Thus REDO of TI is not necessary.d) But REDO of woute-op of T, and Tg is required, as they have co-mmitted but after checkpoint time.e ) Ty and Ts are ignored . They are effectively cancelled rolled back.They are to be aresubmitted .**Instead of redoing every modification on the same data item x , itwould be economical to set X to itifinal modified value and mainta -ining a REDONE list, such that during the bottom up traversal of the READlist , X s notone- siedone.Scanned with CamScannerDisadvantages of deferred update:Limits the concurrent execution of transactions, since all items re -main locked until the transaction steaches its commit point.Advantages of deferred update:Transaction operations never need to be undone ; the seasons being :a) A transaction does not record its changes in the database untilit reaches its commit print (no rollback)b) A transaction will never read the value of an item , that is cosritionby an uncommitted transaction, since items oremain locked until atransaction sleaches ils commit point. (no cascading stollback).Recovery based on immediate update :In this case, when a trancaction issues an update command, thedatabase can be updated immediately without any need to wait forthe freeaction to sreach its commit point . An update operation mustbe recorded in the log on disk , before it is applied to the database ,So that a merovery can be easily made , ' The two types of immediate !update are :a ) If the recovery technique ensures that all updates of a trai-saction are slecorded in the database on dick , before the transactioncommits , there is never a need to REDO any operation of committed( active ) ( committed )transactions . Such an algosuithm is called UNDO / NO - REDO. Algorithmb ) If the transaction is allowed to commit before all ili changes( active ) , ( on commurtist )are written to the database , then we we UNDO / REDOAigoscitim .Considering a system in which concurency control uses the two-phase locking protocol in conjunction with the immediate update tech -nique. Assumption - Checkpoints are included in the log.Recovery wing immediate update in the multiuser environment :Scanned with CamScannerPROCEDURE RIU- Mlise two lists of transactions maintained by the system- a list of committed transactions ( T) since last check point- a list of active transactions ( T)UNDO all the cwsuite-op of active transactions wing UNDO in thereverse order in which they were worutten into the log.REDO call wolite-op of committed transactions cuing REDO in theorden in cofuch they were quitten into the log.UNDO ( woute - Op )undoing a costite - op consists of examining its log entary [WRITET , x, old-val, new. val ] and setting the value of X in the data -bove to the old- val.Undoing a number of voule -op from one / more transactions fromthe log must proceed in the sieverse order from the orden inwhich the operations were written in the log.. Shadow Paging ..A recovery technique that uses a NO- UNDO / NO_ REDO Scheme. It doesSnot use a log, but may siequire a log it srequired by the concurr-ency control subsystem .page - 5Cold ) K2> page - 123> page- 434page - 2<45"page - 3Spage - 6Kcurrent ( working )modification ...... ) page- 5 (new)(image / shadow ofpage_table .ofpointer on upda -tion of page. 5.page table on disk )( typical pictorial representation of shadow paging )Shadow paging considers the database to be made up of a number offixed sige disk pages or blocks, say n.Scanned with CamScannerA page_ table with nentaues is constructed, where the ith page_ tableentry points to the ith database page on disk. The page- table is kept inmain memory if it is not too large . When a transaction begins execution,the current page, table , whose entries point to the most recent / currentdatabase pages on disk, is Copied into a shadow page table , andthis shadow page- table is then saved on disk .Duszing transaction execution, the shadow page - table is never modi -fied . When a write - op is performed , a new copy of the modified data -base is created, but the old copy of the page is not overcoszitten. Thecument page - table entoy is modified to point to the new disk block ,whereas , the shadow page table is not modified and continues to pointto the old disk blocks . For pages updated by the transaction , two versio - -ns are kept - the old version is referenced by the Shadow page tableand the new version by the current page table.To recover from a failure during transaction execution, it is suffici -ent to free the modified database pages and to discard the currentpage table . The state of the database before transaction executionis siecovered by greinstecting the shade page table , so that it bec -omes the current page table once more .Committing a transaction corresponds to discarding the previousShadow page table and freeing the old pages on dick that it referen -Ces. Clearly, this technique may be categorized as NO- UNDO / NO_REDOtechnique for srecovery .Advantages :there is no need to UNDOREDO any transaction operations .Disadvantages :1) Updated database pages change location on disk. Hence it is diffcult to keep siedated database pages close together on disk withoutComplex storage management strategies .") If the page table is large, the overhead of wariting shadow pagetables to disk, as transactions commit, is significant .Scanned with CamScanner11) each time that a transaction commits, the database pages containing the old version of data becomes inaccessible. Such pages areconsidered garbage. ( Garbage may be created alse as a side effectof crashes . ) "Periodically it is necessary to find all the garbage pagesand to add them to the list of free pages. This process called gar -bage collection , imposes additional overhead and comple acity on thesystem .** Concurrent transactions - sharing pages - are difficult to maintainas Simultaneous page - tables need to be updated when such apage is up dated . Complex schemes for shadow page- table main -tenance srequired .. referential integrity ( Navathe , 107.. Integrity constraint - N ( 105 , 15. entity integrity .. Consistency constraint - k ( 10 )J. Bucketoverflows - Korth 209.. External hashing .joptimistic contaruncy contrat- Validation Protoeet ( Deadlock prevention - transactions )Each transaction I executer in 2/3 different phares in its lifetime -depending on whether it is a read-only / update franactions.A ) Read Phase >> I reads values of stores in local variables & updates on localvariables .B ) Validation => Notermination if pi to move to write phase without serialigabilityviolation ; Il failure here, then transaction abort.c ) voili => Temporary focal updates - written to datasourt .15 (Ti )=Validation-Ts (Ti) ; If To (TM ) <TS ( Tu) of Sexual equivalenteto Ti, The.Given Is ( GR) <TS ( Ti)20 Rnish ( Tu ) < Start ( Ti ) => The finishes before Ti - Jeual OR@ start (7;) < rush ( Ta) < Validation ( Ti ) => Tu completes before To startsvalidation of write phases non overlapping s. seerializability maintained.Read BRead ( 3 )quand against cascading rollbackB 2 B- 50. veral w sole only after transactionRead ( A )issuing while was abumitted, starvationA=A+50possible . : confucting fromactions tempomdisplay A+B )<validate > owrite ( B) write ( A)ority blocked to enasil long troumcutionsto frwich .Scanned with CamScanner
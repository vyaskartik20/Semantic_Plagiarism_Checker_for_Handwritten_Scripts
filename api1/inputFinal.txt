I. A transaction Cannot change a database until it teaches ita comuni),point .2. A transaction does not sieach its commet paint und all is. ufrdateoperations are arecorded in the dog and the leg is facce written to dick,If a transaction fails before sreaching it's commit print, it wills not haveechanged the database in any way. Thus UNDO is not needed . it maybe necessary to RENO the effect of the operations of a commiliedhansaction from the log, since their effect may not have been verordedin the database Li.e ., changes sreflected in the carhe but not in thedatabase - checkpoint not taken ] . Thus , such an algosuthm is nameda NO-UNDO / REDO algorithm .We consider a system in which concumency control w.es thetwo-phase locking protocol. To combine deferred update with this proto-Col, we keep all the locks on items in effect until the transaction re -caches its commit point, after which all the locks are sreleased. Thisensures a strict and serializable schedule. Assume that checkpointentries care included in the log.Recovery ming deferred update in the multiuser environment :PROCEDURERDU-Mlise two lists of transactions by the system- Committed transactions list ( T ) since last checkpoint.- Active transactions lust ( T' )RENO all the cuscite operations of the committed transactions fromthe log , in the order in which they were written into the log .The transactions that are active and didnot commit, are effect "ely cancelled and must be resubmitted.REDO ( worite - op )Redoing a write operation conlists of examining its log entory[WRITE T, x, new _val ] and setting the value of item (X ) in the sdatabase to the new-val.(NO_UNAO, Since old-val is not stored ) .Scanned with CamScannerif the REDO operation needs to be idempotent. In fact, the whole reco-very process should be idempotent -, Clearly , if the system teils duringthe recovery process the next recovery might siedo certain omiteoperations that had already been siedone . The sresult of recoveryfrom a crash during srecovery should be the same as the result ofrecovery when there is no crash during srecovery .T.T3T4TSTimeto( checkpoint )( crash )a ) Ti has committed before checkpoint was taken at time t ,, but Ts andTH have not committed yet.b ) Before the system crash , at time to, Ts and To have committedbut Ty and Ts have not .C ) Thus REDO of TI is not necessary.d) But REDO of woute-op of T, and Tg is required, as they have co-mmitted but after checkpoint time.e ) Ty and Ts are ignored . They are effectively cancelled rolled back.They are to be aresubmitted .**Instead of redoing every modification on the same data item x , itwould be economical to set X to itifinal modified value and mainta -ining a REDONE list, such that during the bottom up traversal of the READlist , X s notone- siedone.Scanned with CamScannerDisadvantages of deferred update:Limits the concurrent execution of transactions, since all items re -main locked until the transaction steaches its commit point.Advantages of deferred update:Transaction operations never need to be undone ; the seasons being :a) A transaction does not record its changes in the database untilit reaches its commit print (no rollback)b) A transaction will never read the value of an item , that is cosritionby an uncommitted transaction, since items oremain locked until atransaction sleaches ils commit point. (no cascading stollback).Recovery based on immediate update :In this case, when a trancaction issues an update command, thedatabase can be updated immediately without any need to wait forthe freeaction to sreach its commit point . An update operation mustbe recorded in the log on disk , before it is applied to the database ,So that a merovery can be easily made , ' The two types of immediate !update are :a ) If the recovery technique ensures that all updates of a trai-saction are slecorded in the database on dick , before the transactioncommits , there is never a need to REDO any operation of committed( active ) ( committed )transactions . Such an algosuithm is called UNDO / NO - REDO. Algorithmb ) If the transaction is allowed to commit before all ili changes( active ) , ( on commurtist )are written to the database , then we we UNDO / REDOAigoscitim .Considering a system in which concurency control uses the two-phase locking protocol in conjunction with the immediate update tech -nique. Assumption - Checkpoints are included in the log.Recovery wing immediate update in the multiuser environment :Scanned with CamScannerPROCEDURE RIU- Mlise two lists of transactions maintained by the system- a list of committed transactions ( T) since last check point- a list of active transactions ( T)UNDO all the cwsuite-op of active transactions wing UNDO in thereverse order in which they were worutten into the log.REDO call wolite-op of committed transactions cuing REDO in theorden in cofuch they were quitten into the log.UNDO ( woute - Op )undoing a costite - op consists of examining its log entary [WRITET , x, old-val, new. val ] and setting the value of X in the data -bove to the old- val.Undoing a number of voule -op from one / more transactions fromthe log must proceed in the sieverse order from the orden inwhich the operations were written in the log.. Shadow Paging ..A recovery technique that uses a NO- UNDO / NO_ REDO Scheme. It doesSnot use a log, but may siequire a log it srequired by the concurr-ency control subsystem .page - 5Cold ) K2> page - 123> page- 434page - 2<45"page - 3Spage - 6Kcurrent ( working )modification ...... ) page- 5 (new)(image / shadow ofpage_table .ofpointer on upda -tion of page. 5.page table on disk )( typical pictorial representation of shadow paging )Shadow paging considers the database to be made up of a number offixed sige disk pages or blocks, say n.Scanned with CamScannerA page_ table with nentaues is constructed, where the ith page_ tableentry points to the ith database page on disk. The page- table is kept inmain memory if it is not too large . When a transaction begins execution,the current page, table , whose entries point to the most recent / currentdatabase pages on disk, is Copied into a shadow page table , andthis shadow page- table is then saved on disk .Duszing transaction execution, the shadow page - table is never modi -fied . When a write - op is performed , a new copy of the modified data -base is created, but the old copy of the page is not overcoszitten. Thecument page - table entoy is modified to point to the new disk block ,whereas , the shadow page table is not modified and continues to pointto the old disk blocks . For pages updated by the transaction , two versio - -ns are kept - the old version is referenced by the Shadow page tableand the new version by the current page table.To recover from a failure during transaction execution, it is suffici -ent to free the modified database pages and to discard the currentpage table . The state of the database before transaction executionis siecovered by greinstecting the shade page table , so that it bec -omes the current page table once more .Committing a transaction corresponds to discarding the previousShadow page table and freeing the old pages on dick that it referen -Ces. Clearly, this technique may be categorized as NO- UNDO / NO_REDOtechnique for srecovery .Advantages :there is no need to UNDOREDO any transaction operations .Disadvantages :1) Updated database pages change location on disk. Hence it is diffcult to keep siedated database pages close together on disk withoutComplex storage management strategies .") If the page table is large, the overhead of wariting shadow pagetables to disk, as transactions commit, is significant .Scanned with CamScanner11) each time that a transaction commits, the database pages containing the old version of data becomes inaccessible. Such pages areconsidered garbage. ( Garbage may be created alse as a side effectof crashes . ) "Periodically it is necessary to find all the garbage pagesand to add them to the list of free pages. This process called gar -bage collection , imposes additional overhead and comple acity on thesystem .** Concurrent transactions - sharing pages - are difficult to maintainas Simultaneous page - tables need to be updated when such apage is up dated . Complex schemes for shadow page- table main -tenance srequired .. referential integrity ( Navathe , 107.. Integrity constraint - N ( 105 , 15. entity integrity .. Consistency constraint - k ( 10 )J. Bucketoverflows - Korth 209.. External hashing .joptimistic contaruncy contrat- Validation Protoeet ( Deadlock prevention - transactions )Each transaction I executer in 2/3 different phares in its lifetime -depending on whether it is a read-only / update franactions.A ) Read Phase >> I reads values of stores in local variables & updates on localvariables .B ) Validation => Notermination if pi to move to write phase without serialigabilityviolation ; Il failure here, then transaction abort.c ) voili => Temporary focal updates - written to datasourt .15 (Ti )=Validation-Ts (Ti) ; If To (TM ) <TS ( Tu) of Sexual equivalenteto Ti, The.Given Is ( GR) <TS ( Ti)20 Rnish ( Tu ) < Start ( Ti ) => The finishes before Ti - Jeual OR@ start (7;) < rush ( Ta) < Validation ( Ti ) => Tu completes before To startsvalidation of write phases non overlapping s. seerializability maintained.Read BRead ( 3 )quand against cascading rollbackB 2 B- 50. veral w sole only after transactionRead ( A )issuing while was abumitted, starvationA=A+50possible . : confucting fromactions tempomdisplay A+B )<validate > owrite ( B) write ( A)ority blocked to enasil long troumcutionsto frwich .Scanned with CamScanner